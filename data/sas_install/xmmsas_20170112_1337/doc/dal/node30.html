<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2016 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Reference</TITLE>
<META NAME="description" CONTENT="Reference">
<META NAME="keywords" CONTENT="dal">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="dal.css">

<LINK REL="previous" HREF="node22.html">
<LINK REL="up" HREF="node18.html">
<LINK REL="next" HREF="node31.html">
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE"VLINK="#551A8B" ALINK="#FF0000"><A HREF=http://xmm.esac.esa.int/sas/><IMG SRC="../icons/xmmsaslogo.gif" ALT="XMM-Newton SAS Home Page" HEIGHT=60 WIDTH=60 ALIGN="LEFT"></A>
<DIV ALIGN=RIGHT><B><FONT SIZE=+2>XMM-Newton Science Analysis System</FONT>
<BR>
<BR>
<BR>
dal (dal-1.191.1) [xmmsas_20170112_1337-16.0.0]</B></DIV>
<BR CLEAR=ALL>

<DIV CLASS="navigation"><A HREF="node29.html"><IMG BORDER="0" SRC="../icons/prev.gif" ALT="Column"></A>
<A HREF="node18.html"><IMG BORDER="0" SRC="../icons/up.gif" ALT="F90 DAL API"></A>
<A HREF="node31.html"><IMG BORDER="0" SRC="../icons/next.gif" ALT="Errors"></A>
<A HREF="index.html"><IMG BORDER="0" SRC="../icons/home.gif" ALT="Home"></A>

<A HREF="node36.html"><IMG BORDER="0" SRC="../icons/index.gif" ALT="Index"></A>
<BR><IMG BORDER="0" SRC="../icons/bar.gif">
<BR><A  HREF="../packages.html">Meta Index</A> / <A  HREF="dal.html">Home Page</A> / <A  HREF="node18.html">F90 DAL API</A></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION000185000000000000000">
Reference</A>
</H2>

<P>

<P>

<P>

<P>
 
<UL>
<LI><B>NAME</B>
        <TT>addArray</TT><A NAME="func:f90:addArray"></A><A NAME="5866"></A>( dataSet, name, type, dimensions, units, comment, position )
</LI>
<LI>PURPOSE 
<BR>
Create and add an array to a dataset.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle to a dataset. The newly created array will be added to this dataset.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the array; there must not be a block with this name already
in the dataset.
</LI>
<LI>integer, intent(in) :: type 
<BR>
The data type of the array. It must be one of Integer8, Integer16, Integer32, Real32, Real64
</LI>
<LI>integer(KIND=INT32), dimension(:) :: dimensions 
<BR>
A vector of integer values which desribes the dimensions of the array.
</LI>
<LI>character(len=*), intent(in), optional :: units 
<BR>
The units of the array. This is a passive description of the units, which has no effect on the array's data.
</LI>
<LI>character(len=*), intent(in), optional :: comment 
<BR>
A textual comment which is used to describe the array.
</LI>
<LI>integer, intent(in), optional :: position 
<BR>
This is the ordinal position which the array is to occupy in the given dataset dataSet. The first block in a dataset has position zero.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type( ArrayT ) 
<BR>
The value returned is a handle to the newly created array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
An array is a block. Create and add an array to the specified dataset. The name must be unique. If no position is specified the array is placed at the end of the dataset. The number of blocks will be increaseed by one. All the data elements of the array will have the specified type. The total number of elements is given by the product of the given dimensions. If a position is specified, the array will have the given position e.g. blockNumber( arrayName ) returns the given position. The remaining blocks, if any, will be moved (notionally) to accommodate the new array.

<P>
Whilst the DAL data model is independent of any underlying representation, there is an exceptional facility for handling the notion of the FITS Primary Image. An array with block number zero, and name "PRIMARY", will be treated by the FITS file reader/writer as the FITS primary image.  This does not spoil the purety of the DAL data model, with FITS specific notions, since the interpretation, is made by the FITS File reader/writer, which is a separate piece of software, which is implementated, in terms of the abstract DAL interface.  The restriction of setting the block number to zero, is needed to ensure consistancy of block numbers, between successive create and reads.

<P>
The name, units and comment may be changed. The type, dimensions and position may not be changed.
In the event that the ordinal position is not at the end, the newly created
array is inserted, moving subsequent blocks as necessary.
</LI>
<LI>ERRORS 
<BR>
blockExists invalidBlockPosition
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! two 3-dimensional arrays.
!
! It illustrates the use of the derived types DataSetT and ArrayT.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The first array is filled with unique data before the
! dataset is released (closed).
program example_addarray

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_addarray
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:array"><TT>array</TT></A>
        <A HREF="#func:f90:block"><TT>block</TT></A>
        <A HREF="#func:f90:blockNumber"><TT>blockNumber</TT></A>
        <A HREF="#func:f90:blockType"><TT>blockType</TT></A>
        <A HREF="#func:f90:deleteBlock"><TT>deleteBlock</TT></A>
        <A HREF="#func:f90:hasBlock"><TT>hasBlock</TT></A>
        <A HREF="#func:f90:numberOfBlocks"><TT>numberOfBlocks</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
Boolean and String Data types are not supported.
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B>
        <TT>addAttributes</TT><A NAME="func:f90:addAttributes"></A><A NAME="5898"></A>( destination, source )
</LI>
<LI>PURPOSE 
<BR>
Add the attributes from the source attributable object to the destination attributable object.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(AttributableT), intent(in) :: destination 
<BR>
The destination attributæble object.
</LI>
<LI>type(AttributableT), intent(in) :: source 
<BR>
The source attributæble object.
</LI>
</UL>
</LI>
<LI>RETURNS
         
<BR>
None 
</LI>
<LI>DESCRIPTION 
<BR>
The attributes in source are copied to destination.  Attributes in the destination object, which have the same name are overwritten.
</LI>
<LI>ERRORS 
<BR>
None 
</LI>
<LI>EXAMPLES 
<BR><PRE>
program example_addattributes
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
   
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.false.,"dataset bool comment")
   
  tab = addTable(set,"table",10);
  call addAttributes(attributable(tab),attributable(set))
  call release(tab)
  call release(set)
   
end program example_addattributes
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:setAttributes"><TT>setAttributes</TT></A>
        <A HREF="#func:f90:addAttributes"><TT>addAttributes</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS  
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B>
        <TT>addColumn</TT><A NAME="func:f90:addColumn"></A><A NAME="5915"></A>( table, columnName, dataKind, units, dimensions, comment, position )
</LI>
<LI>PURPOSE 
<BR>
Create and add a column to a table.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle to the table to which a column is to be added.
</LI>
<LI>character(len=*), intent(in) :: columnName 
<BR>
The name of the column. There must not be a column with the same name already in the table.
</LI>
<LI>integer, intent(in) :: dataKind 
<BR>
The type of the column's data. Must be one of Boolean, String, Integer8, Integer16, Interger32, Real32, Real64.
</LI>
<LI>character(len=*), intent(in), optional :: units 
<BR>
The units of the column's data.  This is a passive description of the units and has no effect on the column's data.
</LI>
<LI>character(len=*), intent(in), optional :: comment 
<BR>
A short textual description to be attached to the column.
</LI>
<LI>integer, dimension(:), optional :: dimensions 
<BR>
The dimensions of the column's data.
</LI>
<LI>integer, intent(in), optional :: position 
<BR>
This is the ordinal position which the column is to occupy in the table. The first column in a table has ordinal position zero.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(ColumnT) 
<BR>
The newly created column is returned as a handle.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Create and add a column to the given table. It is not possible to change the data type, position and dimensions of a column.
        The name, label and units of a column may be changed.
        The column handle which is returned is opaque, in that, its contents are hidden from the user, and is an abstract representation of the column.
</LI>
<LI>ERRORS 
<BR>
columnAlreadyExists invalidColumnPosition
</LI>
<LI>EXAMPLES 
<BR><PRE>
program example_addcolumn

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  logical(kind=bool), dimension(:), pointer :: b
  integer(kind=int8), dimension(:), pointer :: i8
  integer(kind=int16), dimension(:), pointer :: i16
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=single), dimension(:), pointer :: r32
  real(kind=double), dimension(:), pointer :: r64
  character(len=1024) :: s
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  b =&gt; boolData(col)
  do i=0,numberOfRows(tab)-1
    b(i) = ( modulo (i,2) .eq. 0 )
  end do

  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  i8 =&gt; int8Data(col)
  write(*,*) shape(i8)
  do i=0,numberOfRows(tab)-1
    i8(i) = i
  end do

  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  i16 =&gt; int16Data(col)
  do i=0,numberOfRows(tab)-1
    i16(i) = 2*i
  end do

  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  i32 =&gt; int32Data(col)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do

  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  r32 =&gt; real32Data(col)
  do i=0,numberOfRows(tab)-1
    r32(i) = 0.5*i
  end do

  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))
  do i=0,numberOfRows(tab)-1
    write(s,*) "string",i
    call setStringCell(col,i,s)
  end do

  call release(set)

end program example_addcolumn
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:columns"><TT>columns</TT></A>
        <A HREF="#func:f90:_deleteColumn"><TT>deleteColumn</TT></A>
        <A HREF="#func:f90:rename"><TT>rename</TT></A>
        <A HREF="#func:f90:relabel"><TT>relabel</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS  
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>addComment</TT><A NAME="func:f90:addComment"></A><A NAME="5938"></A>
</LI>
<LI>PURPOSE 
<BR>
Add a comment string to an attributable object.
</LI>
<LI>INTERFACE 
<BR>
subroutine addCommentToArray( array, comment ) 
<BR>
subroutine addCommentToAttributable( attributable, comment ) 
<BR>
subroutine addCommentToBlock( block, comment ) 
<BR>
subroutine addCommentToDataSet( dataSet, comment ) 
<BR>
subroutine addCommentToTable( table, comment )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>character(len=*), intent(in) :: comment 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
         
<BR>
None 
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR>
None 
</LI>
<LI>EXAMPLES 
<BR><PRE>
program example_addcomment

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab

  set = dataSet("test.dat",CREATE)
  call addComment(set,"this comment is a dataset comment" )
  call addComment(set,"and so is this one." )

  tab = addTable(set,"some table",100)
  call addComment(tab,"this comment is a table comment" )
  call addComment(tab,"and so is this one." )

  call addComment(block(set,0,MODIFY),"Another table comment")
  call release(set)

end program example_addcomment
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addHistory"><TT>addHistory</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
Whilst columns are attributable, column comments are not supported when
        using fits files.  This is a result of an underlying limitation of the fits file standard.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>addHistory</TT><A NAME="func:f90:addHistory"></A><A NAME="5944"></A>
</LI>
<LI>PURPOSE 
<BR>
Add a history string to an attributable object.
</LI>
<LI>INTERFACE 
<BR>
subroutine addHistoryToArray( array, history ) 
<BR>
subroutine addHistoryToAttributable( attributable, history ) 
<BR>
subroutine addHistoryToBlock( block, history ) 
<BR>
subroutine addHistoryToDataSet( dataSet, history ) 
<BR>
subroutine addHistoryToTable( table, history )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableTDataSetT), intent(in) :: attributable 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>character(len=*), intent(in) :: history 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
         
<BR>
None 
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
program example_addhistory

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab

  set = dataSet("test.dat",CREATE)
  call addHistory(set,"this history is a dataset history" )
  call addHistory(set,"and so is this one." )

  tab = addTable(set,"some table",100)
  call addHistory(tab,"this history is a table history" )
  call addHistory(tab,"and so is this one." )

  call addHistory(block(set,0,MODIFY),"Another table history")
  call release(set)

end program example_addhistory
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addComment"><TT>addComment</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
Whilst columns are attributable, column history is not supported.  This is a result of an underlying limitation of the fits file standard.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>addTable</TT><A NAME="func:f90:addTable"></A><A NAME="5950"></A>( dataSet, name, numberOfRows, comment, position )
</LI>
<LI>PURPOSE 
<BR>
Adds a table to a dataset.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle to a dataset to which a table is to be added.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the table. There must not be a block with this name already in the dataset.
</LI>
<LI>integer, intent(in) :: numberOfRows 
<BR>
The number of rows of the table.
</LI>
<LI>character(len=*), intent(in), optional :: comment 
<BR>
A short textual description of the table.
</LI>
<LI>integer, intent(in), optional :: position 
<BR>
The ordinal position of the table within the dataset. The first block within a dataset has ordinal position zero.
</LI>
</UL>
</LI>
<LI>RETURNS  
<BR>
None 

<UL>
<LI>type(TableT) 
<BR>
The newly created table is returned as a handle.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The table name must be unique. If no position is specified, the table is placed at the end of the dataset.
        The number of rows is defined on the table, rather than on the columns, as this ensures that all columns have the same number of rows.
        The handle returned to the newly created table is opaque, in that the contents are hidden.
        In the event that the ordinal position is not at the end, subsequent blocks are moved as necessary.
</LI>
<LI>ERRORS 
<BR>
tableAlreadyExists badTablePosition
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the addtable()
! function is used.
program example_addtable

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(BlockT) blk
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table1",10)
  tab = addTable(set,"table2",100)
  tab = addTable(set,"table3",1000)

  do i=0,numberOfBlocks( set ) - 1
    blk = block( set, i, MODIFY )
    write(*,*) name( blk )
    call addComment( blk, "A table comment" )
  end do

  call release(set)

end program example_addtable
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:deleteBlock"><TT>deleteBlock</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
None known.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>array</TT><A NAME="func:f90:array"></A><A NAME="5956"></A>
</LI>
<LI>PURPOSE 
<BR>
Get an array from a dataset.
</LI>
<LI>INTERFACE 
<BR>
function arrayWithNumber( dataSet, blockNumber, mode ) 
<BR>
function arrayWithName( dataSet, blockName, mode )
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: blockName 
<BR>
The name of the array to get.
</LI>
<LI>integer, intent(in) :: blockNumber 
<BR>
The ordinal position of the array to get.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle to the dataset from which the array will be retrieved.
</LI>
<LI>integer, intent(in) :: mode 
<BR>
The access mode which the retrieved array should have. It must be one
        of the enumeration values: READ, WRITE or MODIFY
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(ArrayT) 
<BR>
A handle, to the retrieved array, is returned. All subsequent operations on this handle will operate on the actuall array stored within the dataset.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Retrieve a particular array from a given dataset. The array may be
        specified either by name or by number (ordinal position within the
        dataset).
</LI>
<LI>ERRORS 
<BR>
arrayNotFound
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example, a dataset is created containing
! a 3-dimensional array. The array is filled with unique
! numbers, before the dataset is released (closed).
!
! The dataset is then reopened (with READ access),
! and the array's data is displayed.
program example_array

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  integer(kind=int32), dimension(:,:,:), pointer :: a
  integer(kind=int32), dimension(:), pointer :: ad
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr = addArray(set, "some array", INTEGER32, dimensions=s )

  ! fill with unique numbers
  a =&gt; int32Array3Data(arr)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a(i,j,k) = n
        n = n + 1
      end do
    end do
  end do

  call release(arr)
  call release(set)

  ! create a set
  set = dataSet("test.dat",READ)
  arr = array(set, "some array", READ)
  ad =&gt; int32Data( arr )

  do n = 0, numberOfElements( arr ) - 1
    write(*,*) ad( n )
  end do

  call release(set)

end program example_array
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addArray"><TT>addArray</TT></A>
        <A HREF="#func:f90:block"><TT>block</TT></A>
        <A HREF="#func:f90:blockType"><TT>blockType</TT></A>
        <A HREF="#func:f90:hasBlock"><TT>hasBlock</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
ARRAY_BLOCK
</LI>
<LI>PURPOSE 
<BR>
Used to indicate a block of type array.
</LI>
<LI>DESCRIPTION 
<BR>
A block is either an array or a table. The function blockType may
        be used to determine the type of a given block. In the event that a
        block is an array the call blockType( someBlock ) will return the value
        ARRAY_BLOCK.
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created containing
! 2 arrays and 2 tables.
!
! A simple loop then iterates over the dataset's
! blocks printing appropriate messages.
! The first two blocks will have ARRAY_BLOCK block type.
! The second two blocks will have TABLE_BLOCK block type.
program example_blocktype

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(BlockT) blk
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr = addArray(set, "block0", INTEGER32, dimensions=s )
  arr = addArray(set, "block1", INTEGER32, dimensions=s )
  tab = addTable(set, "block2", 5 )
  tab = addTable(set, "block3", 5 )

  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, READ )

    if( blockType( block( set, i, READ ) ) .eq. ARRAY_BLOCK ) then 
      write(*,*) "The block with name ", name( blk ), " is an array."
      arr = array( set, i, READ )
      write(*,*) "It has ", numberOfDimensions( arr ), " dimensions."
    end if

    if( blockType( block( set, i, READ ) ) .eq. TABLE_BLOCK ) then 
      write(*,*) "The block with name ", name( blk ), " is a table."
      tab = table( set, i )
      write(*,*) "It has ", numberOfRows( tab ), " rows."
    end if
  end do

  call release(arr)
  call release(set)

end program example_blocktype
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addArray"><TT>addArray</TT></A>
        <A HREF="#func:f90:block"><TT>block</TT></A>
        <A HREF="#func:f90:blockType"><TT>blockType</TT></A>
        <A HREF="#func:f90:hasBlock"><TT>hasBlock</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>
ArrayT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare array handles.
</LI>
<LI>DESCRIPTION 
<BR>
The Array type is derived from the Attributable type, which means that
        an array is attributable, and hence may contain attributes.
        An object of type ArrayT may be converted to an object of type
        AttributableT, BlockT or LabelledT.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! two 3-dimensional arrays.
!
! It illustrates the use of the derived types DataSetT and ArrayT.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The first array is filled with unique data before the
! dataset is released (closed).
program example_addarray

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_addarray
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addArray"><TT>addArray</TT></A>
        <A HREF="#func:f90:array"><TT>array</TT></A>
        <A HREF="#func:f90:attributable"><TT>attributable</TT></A>
        AttributeT
        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        AttributableT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>attributable</TT><A NAME="func:f90:attributable"></A><A NAME="5995"></A>
</LI>
<LI>PURPOSE 
<BR>
Convert a handle to an Attributable handle (AttributeT).
</LI>
<LI>INTERFACE 
<BR>
function arrayAttributable( array ) 
<BR>
function blockAttributable( block ) 
<BR>
function columnAttributable( column ) 
<BR>
function datasetAttributable( dataset ) 
<BR>
function tableAttributable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
Convert an array to base type  AttributableT
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
Convert a block to base type  AttributableT
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
Convert a column to base type  AttributableT
</LI>
<LI>type(DataSetT), intent(in) :: dataset 
<BR>
Convert a dataset to base type  AttributableT
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
Convert a table to base type  AttributableT
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(AttributableT) 
<BR>
A handle to the Attributable base object.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Convert a handle of a derived type of base type Attributable, to AttributableT.
        This function allows the programmer to create generic routines, based
        on the Attributæble type, which is the base class for ArrayT, BlockT,
        ColumnT, DataSetT, and TableT.
</LI>
<LI>ERRORS 
<BR>
None
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example, a dataset is created with one table and one
! array.
! Two attributes are added to each of the dataset, table and array.
!
! The generic subroutine displayAttributes, which operates on the
! AttributableT base type, displays the attributes contained in
! each of the dataset, table and array.
subroutine displayAttributes( thisAttributable )
  use dal

  implicit none

  type(AttributableT) thisAttributable
  type(AttributeT) att
  integer i

  do i = 0, numberOfAttributes( thisAttributable ) - 1
    att = attribute( thisAttributable, i )
    write(*,*) name( att ), stringAttribute( att ), units( att ), label( att )
  end do

end subroutine displayAttributes

program example_attributable
   
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset first bool comment")
  call setAttribute(set,"sbool2",.true.,"dataset second comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(set,"int1",1,"table first integer comment","kg")
  call setAttribute(set,"int2",2,"table second integer comment","mm")

  arr = addArray(set, "array", INTEGER32, dimensions=s )
  call setAttribute(set,"real1",1.1,"array first real comment","kN")
  call setAttribute(set,"real2",2.3,"array second real comment","rad")

  call displayAttributes( attributable( set ) )
  call displayAttributes( attributable( tab ) )
  call displayAttributes( attributable( arr ) )

  call release(set)
   
end program example_attributable
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
AttributableT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
AttributableT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare attributable handles.
</LI>
<LI>DESCRIPTION 
<BR>
The derived type AttributableT is a base type for ArrayT, BlockT,
        ColumnT, DataSetT and TableT.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See attributable.
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:attributable"><TT>attributable</TT></A>
        ArrayT
        BlockT
        ColumnT 
        DataSetT 
        TableT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
None known.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>attribute</TT><A NAME="func:f90:attribute"></A><A NAME="6001"></A>
</LI>
<LI>PURPOSE 
<BR>
Get an attribute from an attributable object.
</LI>
<LI>INTERFACE 
<BR>
function arrayAttributeWithName( array, name ) 
<BR>
function arrayAttributeWithNumber( array, number ) 
<BR>
function attributableAttributeWithName( attributable, name ) 
<BR>
function attributableAttributeWithNumber( attributable, number ) 
<BR>
function blockAttributeWithName( block, name ) 
<BR>
function blockAttributeWithNumber( block, number ) 
<BR>
function columnAttributeWithName( column, name ) 
<BR>
function columnAttributeWithNumber( column, number) 
<BR>
function dataSetAttributeWithName( dataSet, name ) 
<BR>
function dataSetAttributeWithNumber( dataSet, number ) 
<BR>
function tableAttributeWithName( table, name ) 
<BR>
function tableAttributeWithNumber( table, number )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of an array object from which to get the attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of an attributable object from which to get the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of a block object from which to get the attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of a column object from which to get the attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of an attribute object from which to get the attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the attribute to get.
</LI>
<LI>integer, intent(in) :: number 
<BR>
The ordinal number of the attribute to get.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of a table object from which to get the attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(AttributeT) 
<BR>
The attribute handle of the retrieved attribute.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Get an attribute, either by name or by number (ordinal position within
        the attributable object) from an attributable object.
</LI>
<LI>ERRORS 
<BR>
attributeNotFound invalidAttributeNumber
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example a dataset with a table is ! created.
! Two attributes are added to each of the dataset ! and table.
! The attribute names of the dataset are displayed using
! access-by-number, and the table attribute names are displayed
! using access-by-name.
program example_attribute

  use dal
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
   
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.true.,"dataset bool comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"sbool1",.false.,"table bool comment")
  call setAttribute(tab,"sbool2",.true.,"table bool comment")

  write(*,*) name( attribute( set, 0 ))
  write(*,*) name( attribute( set, 1 ))
  write(*,*) name( attribute( tab, "sbool1" ))
  write(*,*) name( attribute( tab, "sbool2" ))

  call release(set)
   
end program example_attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
AttributableT 
        AttributeT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
AttributeT
</LI>
<LI>PURPOSE 
<BR>
A derived type used to declare Attribute handles.
</LI>
<LI>DESCRIPTION 
<BR>
An attribute has a name, value, comment and units. The value of an
        attribute is not strongly typed; type conversions are carried out when
        the attributes's value is accessed.
        Objects of type AttributeT are not attributes but attribute-handles. An
        attribute handle provides an abstract access layer to the internal
        structure of an attribute.
        An attribute belongs (is owned by) to an attributable (or any of its
        derived types) object.  The parent (owner) of an attribute is an
        attributable object. An attribute is created with a call to
        addAttribute, which creates and adds a new attribute to an attributable
        object. An attribute is retrieved from an attributable object with the
        attribute function.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See addAtribute.
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addAttribute"><TT>addAttribute</TT></A>
        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        <A HREF="#func:f90:parent"><TT>parent</TT></A>
        AttributableT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>block</TT><A NAME="func:f90:block"></A><A NAME="6021"></A>
</LI>
<LI>PURPOSE 
<BR>
Convert a handle, of derived type of base type Block, to BlockT
</LI>
<LI>INTERFACE 
<BR>
function arrayBlock( array ) 
<BR>
function tableBlock( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
Handle of array which is to be converted into a handle of BlockT.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
Handle of table which is to be converted into a handle of BlockT.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(BlockT) 
<BR>
A Block handle is returned.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example, a dataset is created with one table and one
! array.
! The generic subroutine displayBlock, which operates on the
! BlockT base type. The blockType() function operates on objects
! of type BlockT.
! The example also sjows blocks being retrieved from the dataset
! both by name and by number.
subroutine displayBlock( thisBlock )
  use dal

  implicit none

  type(BlockT) thisBlock

  write(*,*) "The block with name ", name( thisBlock )

  if( blockType( thisBlock ) .eq. ARRAY_BLOCK ) then
    write(*,*) " is an array."
  end if

  if( blockType( thisBlock ) .eq. TABLE_BLOCK ) then
    write(*,*) " is a table."
  end if

end subroutine displayBlock

subroutine displayBlocks( thisSet )
  use dal

  implicit none

  type(DataSetT) thisSet
  integer i

  do i = 0, numberOfBlocks( thisSet ) - 1
    call displayBlock( block( thisSet, i, READ ) )
  end do

end subroutine displayBlocks

program example_block
   
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table",10);
  arr = addArray(set, "array", INTEGER32, dimensions=s )

  call displayBlock( block( tab ) )
  call displayBlock( block( arr ) )
  call displayBlock( block( set, "table", READ ) )
  call displayBlock( block( set, "array", READ ) )
  call displayBlocks( set )

  call release(set)
   
end program example_block
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
BlockT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>block</TT><A NAME="func:f90:block"></A><A NAME="6024"></A>
</LI>
<LI>PURPOSE 
<BR>
Get a block from a dataset.
</LI>
<LI>INTERFACE 
<BR>
function blockWithNumber( dataSet, blockNumber, mode ) 
<BR>
function blockWithName( dataSet, blockName, mode )
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: blockName 
<BR>
Name of block which is to be retrieved from a dataset.
</LI>
<LI>integer, intent(in) :: blockNumber 
<BR>
Number of block which is to be retrieved from a dataset.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
Handle of a dataset from which a block is to be retrieved.
</LI>
<LI>integer, intent(in) :: mode 
<BR>
The access mode which the retrieved block should have. It must be one
        of the enumeration values: READ, WRITE or MODIFY.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(BlockT) 
<BR>
The Block handle is returned.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The block may be retrieved either by name or by number (i.e. ordinal
        position) from the dataset.
</LI>
<LI>ERRORS 
<BR>
blockNotFound
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example, a dataset is created with one table and one
! array.
! The generic subroutine displayBlock, which operates on the
! BlockT base type. The blockType() function operates on objects
! of type BlockT.
! The example also sjows blocks being retrieved from the dataset
! both by name and by number.
subroutine displayBlock( thisBlock )
  use dal

  implicit none

  type(BlockT) thisBlock

  write(*,*) "The block with name ", name( thisBlock )

  if( blockType( thisBlock ) .eq. ARRAY_BLOCK ) then
    write(*,*) " is an array."
  end if

  if( blockType( thisBlock ) .eq. TABLE_BLOCK ) then
    write(*,*) " is a table."
  end if

end subroutine displayBlock

subroutine displayBlocks( thisSet )
  use dal

  implicit none

  type(DataSetT) thisSet
  integer i

  do i = 0, numberOfBlocks( thisSet ) - 1
    call displayBlock( block( thisSet, i, READ ) )
  end do

end subroutine displayBlocks

program example_block
   
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table",10);
  arr = addArray(set, "array", INTEGER32, dimensions=s )

  call displayBlock( block( tab ) )
  call displayBlock( block( arr ) )
  call displayBlock( block( set, "table", READ ) )
  call displayBlock( block( set, "array", READ ) )
  call displayBlocks( set )

  call release(set)
   
end program example_block
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
BlockT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>blockNumber</TT><A NAME="func:f90:blockNumber"></A><A NAME="6027"></A>( dataSet, blockName )
</LI>
<LI>PURPOSE 
<BR>
Get the number (ordinal position) of a block.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
Handle of a dataset which contains the desired block.
</LI>
<LI>character(len=*), intent(in) :: blockName 
<BR>
The name of the block for which the number is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
The ordinal number (position of the block within the dataset).
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
A dataset contains zero or more blocks. Each block has an ordinal
        number (or position) within its parent dataset.
        This function returns the ordinal position of a block.
</LI>
<LI>ERRORS 
<BR>
blockNotFound
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This example creates a dataset with one
! table and one array.
! The table will have block number 0,
! and the array will have block number 1
subroutine displayBlockNumber( thisBlock )
  use dal

  implicit none

  type(BlockT) thisBlock

  write(*,*) "The block with name ", name( thisBlock ), "has number "
  write(*,*) blockNumber( parent( thisBlock ), name( thisBlock ) )

end subroutine displayBlockNumber

program example_blocknumber
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
   
  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table",10);
  arr = addArray(set, "array", INTEGER32, dimensions=s )

  call displayBlockNumber( block( tab ) )
  call displayBlockNumber( block( arr ) )

  call release(set)
   
end program example_blockNumber
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
BlockT 
        DataSetT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
BlockT
</LI>
<LI>PURPOSE 
<BR>
A derived type used to declare block handle objects.
</LI>
<LI>DESCRIPTION 
<BR>
This type allows generic routines to be writeen, which do not
        need to worry whether a particular block is an array or a table.
        The Block type is derived from the Attributable type, which means that
        a block is attributable, and may thus contain attributes.
</LI>
<LI>EXAMPLES 
<BR>
See block, blockNumber
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addAttribute"><TT>addAttribute</TT></A>
        <A HREF="#func:f90:attributable"><TT>attributable</TT></A>
        AttributæbleT 
        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        AttributeT 
        DataSetT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>blockType</TT><A NAME="func:f90:blockType"></A><A NAME="6039"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the type of a block.
</LI>
<LI>INTERFACE 
<BR>
function blockType( block ) 
<BR>
function blockTypeOfBlockWithName( dataSet, blockName ) 
<BR>
function blockTypeOfBlockWithNumber( dataSet, blockNumber )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle to the block.
</LI>
<LI>character(len=*), intent(in) :: blockName 
<BR>
The name of the block.
</LI>
<LI>integer, intent(in) :: blockNumber 
<BR>
The number of the block.
</LI>
<LI>type(DataSetT), intent(in ) :: dataSet 
<BR>
A handle to the dataset containing the desired block.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
Returns ARRAY_BLOCK if the block is an array and returns TABLE_BLOCK if the block
        is a table.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Determines the type of the given block.
</LI>
<LI>ERRORS 
<BR>
blockNotFound
</LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created containing
! 2 arrays and 2 tables.
!
! A simple loop then iterates over the dataset's
! blocks printing appropriate messages.
! The first two blocks will have ARRAY_BLOCK block type.
! The second two blocks will have TABLE_BLOCK block type.
program example_blocktype

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(BlockT) blk
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr = addArray(set, "block0", INTEGER32, dimensions=s )
  arr = addArray(set, "block1", INTEGER32, dimensions=s )
  tab = addTable(set, "block2", 5 )
  tab = addTable(set, "block3", 5 )

  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, READ )

    if( blockType( block( set, i, READ ) ) .eq. ARRAY_BLOCK ) then 
      write(*,*) "The block with name ", name( blk ), " is an array."
      arr = array( set, i, READ )
      write(*,*) "It has ", numberOfDimensions( arr ), " dimensions."
    end if

    if( blockType( block( set, i, READ ) ) .eq. TABLE_BLOCK ) then 
      write(*,*) "The block with name ", name( blk ), " is a table."
      tab = table( set, i )
      write(*,*) "It has ", numberOfRows( tab ), " rows."
    end if
  end do

  call release(arr)
  call release(set)

end program example_blocktype
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addBlock"><TT>addBlock</TT></A>
        <A HREF="#func:f90:block"><TT>block</TT></A>
        BlockT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
BOOL
</LI>
<LI>PURPOSE 
<BR>
Native fortran enumeration which is used to indicate boolean data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
N/A
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
BOOLEAN
</LI>
<LI>PURPOSE 
<BR>
Enumeration value which is used to indicate DAL boolean data.
</LI>
<LI>DESCRIPTION 
<BR>
This value should not be confused with the Native fortran value BOOL.
Boolean data values are 4-byte logicals.
</LI>
<LI>EXAMPLES 
<BR>
N/A
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>booleanAttribute</TT><A NAME="func:f90:booleanAttribute"></A><A NAME="6048"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as a boolean.
</LI>
<LI>INTERFACE 
<BR>
function booleanArrayAttribute( array, name ) 
<BR>
function booleanAttributableAttribute( attributable, name ) 
<BR>
function booleanAttribute( attribute ) 
<BR>
function booleanBlockAttribute( block, name ) 
<BR>
function booleanColumnAttribute( column, name ) 
<BR>
function booleanDataSetAttribute( dataSet, name ) 
<BR>
function booleanTableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>character(len=*), intent(in) :: name 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Gets the value of an attribute as a boolean from the specified object. In the event that the data conversion is not possible an error is raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how boolean attributes are used.
! The program creates a dataset containing two boolean attributes,
! together with a table containing two boolean attributes.
! The attributes are then accessed, by name, with
! the booleanAttribute() function.
! Also, it is shown how to access the attributes by position.
program example_booleanattribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.true.,"dataset bool comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"sbool1",.false.,"dataset bool comment")
  call setAttribute(tab,"sbool2",.true.,"dataset bool comment")

  write(*,*) booleanAttribute( set, "sbool1" ) ! output 'F'
  write(*,*) booleanAttribute( set, "sbool2" ) ! output 'T'
  write(*,*) booleanAttribute( tab, "sbool1" ) ! output 'F'
  write(*,*) booleanAttribute( tab, "sbool2" ) ! output 'T'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) booleanAttribute( att ) ! output the sequence 'F','T'
  end do

  call release(set)
   
end program example_booleanattribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
AttributeT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray2Data</TT><A NAME="func:f90:boolArray2Data"></A><A NAME="6051"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from an array or column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolArrayArray2Data( array ) 
<BR>
function boolColumnArray2DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
</LI>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>integer, intent(in) :: row
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; boolArray2Data(col1,k)
    c2 =&gt; boolArray2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = .false.
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
boolArrayArray2Data is not implemented.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray2Data</TT><A NAME="func:f90:boolArray2Data"></A><A NAME="6054"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; boolArray2Data(col1)
  c2 =&gt; boolArray2Data(col1)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = .false.
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray3Data</TT><A NAME="func:f90:boolArray3Data"></A><A NAME="6057"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from an array or column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolArrayArray3Data( array ) 
<BR>
function boolColumnArray3DataElement( column, row ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; boolArray3Data(col1,l)
    c2 =&gt; boolArray3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = .false.
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray3Data</TT><A NAME="func:f90:boolArray3Data"></A><A NAME="6060"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from a column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; boolArray3Data(col1)
  c2 =&gt; boolArray3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = .false.
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray4Data</TT><A NAME="func:f90:boolArray4Data"></A><A NAME="6063"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; boolArray4Data(col1,m)
    c2 =&gt; boolArray4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = .false.
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolArray4Data</TT><A NAME="func:f90:boolArray4Data"></A><A NAME="6066"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function boolColumnArray4Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; boolArray3Data(col1)
  c2 =&gt; boolArray3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = .false.
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolData</TT><A NAME="func:f90:boolData"></A><A NAME="6069"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the boolean data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function boolArrayData( array ) 
<BR>
function boolColumnData( column ) 
<BR>
function boolColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array which contains the data to be accessed.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The number of the column cell which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:), pointer 
<BR>
The data is returned as a flat vector regardless of the dimensionality of the
data.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned in a vector regardles of the dimensionality of the data. In particular, when accessing a scalar column cell, a vector of length 1 is returned, which contains the single scalar value.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_booldata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:,:,:,:), pointer :: c1, c2
  logical(kind=BOOL), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; boolArray4Data(col1)
  c2 =&gt; boolArray4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = .false.
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; boolData( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_booldata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolVectorData</TT><A NAME="func:f90:boolVectorData"></A><A NAME="6072"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the data from an array or column cell containing vector array data.
</LI>
<LI>INTERFACE 
<BR>
function boolArrayVectorData( array ) 
<BR>
function boolColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array which contains the data to be accessed.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The number of the column cell which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell).
! The data is output on a cell-by-cell basis and accessing
! the cell as a flat vector.
program example_boolcellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; boolVectorData(col1,m)
    c2 =&gt; boolVectorData(col2,m)
    do i=0,2 
      c1(i) = .false.
      c2(i) = c1(i)
      n = n + 1
    end do
    ! release(col1)
    ! release(col2)
  end do

  ! Output col2
  do m=0,numberOfRows(tab) - 1
    c2 =&gt; boolVectorData(col2,m)
    do n=0,numberOfElements(col2) - 1
      write(*,*) c2(n)
    end do
    ! release(col2)
  end do

  call release(set)

end program example_boolcellvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>boolVectorData</TT><A NAME="func:f90:boolVectorData"></A><A NAME="6075"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the data from a column containing vector array data.
</LI>
<LI>INTERFACE 
<BR>
function boolColumnVectorData( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array which contains the data to be accessed.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The number of the column cell which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical(kind=bool), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  logical(kind=BOOL), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", BOOLEAN, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; boolVectorData(col1)
  c2 =&gt; boolVectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = .false.
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>clobber</TT><A NAME="func:f90:clobber"></A><A NAME="6078"></A>()
</LI>
<LI>PURPOSE 
<BR>
Get the clobber setting.
</LI>
<LI>ARGUMENTS 
<BR>
<BR>
None 
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR>
True, if the SAS Clobber setting is set, false otherwise.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The SAS Clobber setting is determined by the setting of the SAS_CLOBBER
        environment variable.
</LI>
<LI>ERRORS 
<BR>
None.
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the clobber() function is
! used.
program example_clobber

  use dal
  implicit none
   
  if( clobber() ) then
    write(*,*) "The SAS_CLOBBER environment variable is set"
  else
    write(*,*) "The SAS_CLOBBER environment variable is not set"
  endif

end program example_clobber
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>column</TT><A NAME="func:f90:column"></A><A NAME="6081"></A>
</LI>
<LI>PURPOSE 
<BR>
Get a column from a table.
</LI>
<LI>INTERFACE 
<BR>
column

<UL>
<LI>functon columnWithName( table, columnName, mode )
</LI>
<LI>function columnWithNumber( table, columnNumber, mode )
</LI>
</UL>
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table from which to get the column.
</LI>
<LI>character(len=*), intent(in) :: columnName 
<BR>
The name of the column in the table.
</LI>
<LI>integer, intent(in) :: columnNumber 
<BR>
The ordinal number of the column. It must be in the range 0 to n - 1, where n is the number of columns in the table.
</LI>
<LI>integer, intent(in) :: mode
        The access mode which will be given to the retrieved column. The options are: READ|WRITE|MODIFY
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(ColumnT) 
<BR>
A handle of the retrieved column.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
In the event that the column was not found an error is raised. An error is usually raised when the column name does not exist or the ordinal number is invalid.
        The handle (which is essentailly a pointer to the internal column, but this detail is hidden by the API) which is returned may be (in fact this is the only way to modify a column) used to perform various operations on the column.
        A column is deleted from a table with deleteColumn.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how the column() function is used.
! The column by name is used to get a column and rename it.
! The column by number is used to iterate over all
! columns in the table to output the name, type and units.
program example_column

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"col1",INTEGER32,units="m1",comment="in32 column")
  col = addColumn(tab,"col2",INTEGER32,units="m2",comment="in32 column")
  col = addColumn(tab,"col3",INTEGER32,units="m3",comment="in32 column")

  col = column( tab, "col2", MODIFY )
  call rename( col, "col4" )

  do i =0, numberOfColumns( tab ) - 1
    col = column( tab, i, READ )
    write(*,*) name( col ), columnDataType( col ), units( col )
  end do

  call release(set)

end program example_column
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
        ColumnT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>columnNumber</TT><A NAME="func:f90:columnNumber"></A><A NAME="6087"></A>( table, columnName )
</LI>
<LI>PURPOSE 
<BR>
Get the number (ordinal position) of a column.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The table containing the column for which the number is required.
</LI>
<LI>character(len=*), intent(in) :: columnName 
<BR>
The name of the column.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
The value returned will be in the range 0 to n - 1, where n is the number of columns in the table.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The first column in a table has number zero. In the event that a column with the specified name is not found in the given table, an error will be raised.
        A column's number will change when additional columns are added, or when columns are deleted to earlier positions.
</LI>
<LI>ERRORS 
<BR>
columnNotFound
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples shows how the columnNumber() function
! is used.
program example_columnnumber

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")

  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column", &amp;
          position=columnNumber( tab, "int32" ) )

  do i = 0, numberOfColumns( tab ) - 1
    col = column( tab, i, READ )
    write(*,*) name( col )
  end do

  call release(set)

end program example_columnnumber
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
ColumnT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare column handles.
</LI>
<LI>DESCRIPTION 
<BR>
A derived type which is used to declare column handles.
        A column always belongs to a table.  A columns is created with the addColumn() function, which requires a table as an argument. This table becomes the owning parent of the column.
        The Column type is derived from the Attributable type, which means that
        a column is attributable, and may thus contain attributes.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See addColumn
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
        <A HREF="#func:f90:attributable"><TT>attributable</TT></A>
        AttributableT 
        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        AttributeT 
        <A HREF="#func:f90:column"><TT>column</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>copyBlock</TT><A NAME="func:f90:copyBlock"></A><A NAME="6105"></A>( set, block, newName )
</LI>
<LI>PURPOSE 
<BR>
Copy a block.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: set 
<BR>
The handle of a dataset to which the block should be copied.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
The handle of a block which is to be copied to the dataset.
</LI>
<LI>character(len=*), intent(in), optional :: newName 
<BR>
An optional name of the newly copied block.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Copy a block to a dataset. The source block may reside in a differnt dataset from set.
        A duplicate of the source block is created, either with the same name as the source block or with a new name speicfied with newName.
 If newName is not specified, the newly created block will have the same name as the source block. It will be necessary to specify the name of the new block when block resides in the dataset set.
 In the event that a block cannot be copied (e.g. non-unique name) an error will be raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example a dataset is created, with
! three tables.
!
! The created datanew is then copied to a new dataset.

! A simple loop then iterates over the
! dataset's blocks (a table may be treated as a block)
! Each block is copyied to a second dataset, and
! then displays the name of each new block (which actually
! will be the same name as the source block); a comment
! is added to each new block.
program example_copyblock

  use dal
  
  implicit none

  type(DataSetT) set1, set2
  type(TableT) tab
  type(BlockT) blk
  integer i

  set1 = dataSet("test.dat",CREATE)
  tab = addTable(set1,"first table",100)
  tab = addTable(set1,"second table",1000)
  tab = addTable(set1,"third table",10000)

  set2 = dataSet("test1.dat",CREATE)

  do i = 0, numberOfBlocks( set1 ) - 1
    blk = block( set1, i, MODIFY )
    call copyBlock( set2, blk )
    blk = block( set2, i, MODIFY )
    call addComment( blk, "Copied from test.dat" )
  end do

  call release(set1)
  call release(set2)

end program example_copyblock
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addBlock"><TT>addBlock</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>copyColumn</TT><A NAME="func:f90:copyColumn"></A><A NAME="6111"></A>( table, column, newName )
</LI>
<LI>PURPOSE 
<BR>
Copy a column.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table to which the column should be copied.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
The handle of a column to be copied.
</LI>
<LI>character(len=*), intent(in), optional :: newName 
<BR>
An optional name for the newly copied column should have.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
The source column may reside in a different table. A duplicate of the sourcee column is created, whose name is either the same as the source column's name or a new name specified with newName.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how to use the copyColumn function.
program example_copycolumn

  use dal
  
  implicit none

  type(DataSetT) set1, set2
  type(TableT) tab1, tab2
  type(ColumnT) col1, col2, col3, col4
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=single), dimension(:), pointer :: r32
  integer i

  set1 = dataSet("test.dat",CREATE)
  tab1 = addTable(set1,"some table",100)

  col1 = addColumn(tab1,"col1",INTEGER32,units="m",comment="in32 column")
  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab1)-1
    i32(i) = 3*i
  end do
  call release( col1)

  col2 = addColumn(tab1,"col2",REAL32,units="Dm",comment="real32 column")
  r32 =&gt; real32Data(col2)
  do i=0,numberOfRows(tab1)-1
    r32(i) = 0.5*i
  end do
  call release( col2)

  set2 = dataSet("test1.dat",CREATE)
  tab2 = addTable(set2,"some table",100)
  call copyColumn( tab2, col1 )
  call copyColumn( tab2, col2, "col3" )

  col3 = column( tab2, name( col1 ), READ )
  col4 = column( tab2, "col3", READ )
  i32 =&gt; int32Data(col3)
  r32 =&gt; real32Data(col4)
  do i = 0, numberOfRows( tab2 ) - 1
    write(*,*) i32(i), r32(i) 
  end do
  call release(col3)
  call release(col4)

  call release(set1)
  call release(set2)

end program example_copycolumn
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>copyDataSet</TT><A NAME="func:f90:copyDataSet"></A><A NAME="6117"></A>( sourceName, destName )
</LI>
<LI>PURPOSE 
<BR>
Copy a dataset.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: destName 
<BR>
The name of the destination dataset.
</LI>
<LI>character(len=*), intent(in) :: sourceName 
<BR>
The name of the destination source set.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Copy the dataset with name sourceName to the set with name destName.
        The destination dataset becomes a duplicate of the source dataset.
        In the event that the source dataset is not found an error will be raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example a dataset is created, with
! three tables.
! The created datanew is then copied to a new dataset.
! A simple loop then iterates over the new
! dataset's ! blocks (a table may be treated as a block)
! then displays the name of ! each table, and adds a comment
! to each block (table).
program example_copydataset

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(BlockT) blk
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"first table",100)
  tab = addTable(set,"second table",1000)
  tab = addTable(set,"third table",10000)

  call release(set)

  call copyDataSet( "test.dat", "test1.dat" )

  set = dataSet("test1.dat",READ)
  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, MODIFY )
    write(*,*) name( blk )
    call addComment( blk, "Copied from test.dat" )
  end do

  call release(set)

end program example_copydataset
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addDataSet"><TT>addDataSet</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
This subroutine has been implemented with a subprocess call to the unix rm command.  The DAL has no control over the overall behaviour of this command.

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>clone</TT><A NAME="func:f90:clone"></A><A NAME="6123"></A>( from, to, mode, memoryModel )
</LI>
<LI>PURPOSE 
<BR>
Clone a dataset.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: from 
<BR>
The name of the dataset to be cloned.
</LI>
<LI>character(len=*), intent(in) :: to 
<BR>
The name of the clone.
</LI>
<LI>integer, intent(in) :: mode 
<BR>
The access mode which the dataset should be used with. It must be one of the following values:
        
<UL>
<LI>MODIFY All changes made to the clone will be written saved upon closure.
</LI>
<LI>TEMP The clone is discarded upon closure.
        
</LI>
</UL>
</LI>
<LI>integer, intent(in), optional :: memoryModel 
<BR>
This specifies a hint to which the memory model should be used. The following values are possible:
        
<UL>
<LI>HIGH_MEMORY 
</LI>
<LI>HIGH_LOW_MEMORY
</LI>
<LI>LOW
</LI>
<LI>USE_ENVIRONMENT
        
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataSetT) :: dataSet 
<BR>
A handle to the clone .
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the clone
! function.
program example_clone

  use dal
  
  implicit none

  type(DataSetT) set
  type(DataSetT) clonedSet

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1", 10, "mm", "attribute comment" )
  call release(set)

  set = dataSet("test.dat",MODIFY)
  call setAttribute(set,"att1", 10, "mm", "attribute comment" )
  call release(set)


  clonedSet = clone("test.dat","test2.dat",MODIFY)
  call setAttribute(clonedSet,"att2", 10, "mm", "attribute comment" )
  call release(clonedSet)
  
  set = dataSet("test2.dat",READ)
  write(*,*) "att2 = ", int32Attribute( set, "att2" ); 
  call release(set)

end program example_clone
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:dataSet"><TT>dataSet</TT></A>
        <A HREF="#func:f90:release"><TT>release</TT></A>
        <A HREF="#func:f90:ssetexists"><TT>setexist</TT></A>
        HIGH_MEMORY 
        HIGH_LOW_MEMORY 
        LOW_MEMORY 
        USE_ENVIRONMENT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>copyRows</TT><A NAME="func:f90:copyRows"></A><A NAME="6135"></A>( table, from, to, count )
</LI>
<LI>PURPOSE 
<BR>
Copy a range of rows.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table within which the rows are to be copied.
</LI>
<LI>integer, intent(in) :: from 
<BR>
The source row number. 'from' must be in the range 0 to n, where n is the number of rows in the table. The source row numbers will then be in the range 'from' to 'from + count'.  See the description below for additional constraints.
</LI>
<LI>integer, intent(in) :: to 
<BR>
The destination row number. 'to' must be in the range 0 to n, where n is the number of rows in the table.  The destination row numbers will then be 'to' to 'to + count'.  See the description below for additional constraints.
</LI>
<LI>integer, intent(in), optional :: count 
<BR>
The number of rows which should be copied.  See the description below for additional constraints.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Copy a range of rows from one location to another, within a table.
        The triple (from, to, count ) must be logically possible e.g. from + count &lt;= n and to + count &lt;= n, where n is the number of rows in the table.

<P>
Memory Considerations
        This operation of copying rows within a table is very expensive.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how to use the copyRows subroutine. 
program example_copyrows

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=single), dimension(:), pointer :: r32
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",10)

  col1 = addColumn(tab,"col1",INTEGER32,units="m",comment="in32 column")
  i32 =&gt; int32Data(col1)

  do i=0,4
    i32(i) = 3*i
  end do

  call release( col1)

  col2 = addColumn(tab,"col2",REAL32,units="Dm",comment="real32 column")
  r32 =&gt; real32Data(col2)

  do i=0,4
    r32(i) = 0.5*i
  end do

  call release( col2)

  call copyRows( tab, 0, 5, 5 ) ! copy range [0,4] to [5,9]

  i32 =&gt; int32Data(col1)
  r32 =&gt; real32Data(col2)

  do i = 0, numberOfRows( tab ) - 1
    write(*,*) i32(i), r32(i) 
  end do

  call release(col1)
  call release(col2)

  call release(set)

end program example_copyrows
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:deleteRows"><TT>deleteRows</TT></A>
        <A HREF="#func:f90:insertRows"><TT>insertRows</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>count</TT><A NAME="func:f90:count"></A><A NAME="6144"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the count-value from the seek range of an object.
</LI>
<LI>INTERFACE 
<BR>
function countColumn( column )
        function countTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>type(TableT), intent(in) :: table
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the seek functions
! are used.
! This subroutine will dispaly the seek values of the given table and column.
subroutine whatisseek(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: col

  write(*,*) from( tab ), count( tab )

  col = column(tab,"x",MODIFY)
  write(*,*) from( col ), count( col )

end subroutine whatisseek

program example_seek

  use dal

  implicit none

  type(DataSetT) :: set
  type(TableT) :: tab
  type(ColumnT) :: col

  interface
    subroutine whatisseek( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine whatisseek
  end interface

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"events",10)
  col = addColumn(tab,"x",real32,"mm")

  call forEachSubTable(tab,whatisseek)

  call release(set)

end program example_seek
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:from"><TT>from</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
CREATE
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate that a new dataset should be created.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
Most of the examples show how to use the CREATE enumeration value.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>dataComponent</TT><A NAME="func:f90:dataComponent"></A><A NAME="6150"></A>
</LI>
<LI>PURPOSE 
<BR>
Convert a subclass of DataComponent into DataComponent.
</LI>
<LI>INTERFACE 
<BR>
function arrayDataComponent( array )
        function columnDataComponent( column ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
The handle of an array which is to be converted to a DataComponent 
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
The handle of a column which is to be converted to a DataComponent 
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataComponentT) 
<BR>
The converted object is returned as a handle to a DataComponent object.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example illustrates the use of the dataComponent() function.
! The units of objects with data type BOOLEAN and STRING are meaningless
! and so are not displayed.
subroutine displayUnits( dcomponent )
  use dal
 
  implicit none

  type(DataComponentT) dcomponent
  integer dattype

  dattype = dataType( dcomponent )
  write(*,*) dattype
  if(dattype.eq.INTEGER8.or.dattype.eq.INTEGER16.or.dattype.eq.INTEGER32 &amp;
    .or.dattype.eq.REAL32.or.dattype.eq.REAL64) then
    write(*,*) units( dcomponent )
  end if

end subroutine displayUnits

program example_datacomponent

  use dal
  
  implicit none

  type(ArrayT) arr
  type(BlockT) blk
  type(ColumnT) col
  type(DataSetT) set
  type(TableT) tab
  integer i, j
  integer, dimension(3), parameter :: s = (/ 2,3,4 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))
  arr = addArray(set, "array1", INTEGER16, dimensions=s, units="klm" )
  arr = addArray(set, "array2", INTEGER32, dimensions=s, units="kla" )

  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, READ )
    if( blockType( blk ).eq.ARRAY_BLOCK ) then
      arr = array( set, name( blk ), READ )
      call displayUnits( dataComponent( arr ) )
    else
      tab = table( set, name( blk ) )
      do j = 0, numberOfColumns( tab ) - 1
        col = column( tab, j, READ )
        call displayUnits( dataComponent( col ) )
      end do
    end if
  end do
  call release(set)

end program example_datacomponent
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
DataComponentT
</LI>
<LI>PURPOSE 
<BR>
Used to declare DataComponent handles.
</LI>
<LI>DESCRIPTION 
<BR>
DataComponent is a C++ class whose details are not available to the F90 programmer. Access to this underlying class is achieved through the DataComponentT handle.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See dataComponent.
</LI>
<LI>SEE ALSO 
<BR>
The description on handles and the description of class hierarchies etc.
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>dataSet</TT><A NAME="func:f90:dataSet"></A><A NAME="6153"></A>( dataSetname, mode, memoryModel )
</LI>
<LI>PURPOSE 
<BR>
Open dataset with the given name.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: dataSetName 
<BR>
The name of the dataset.
</LI>
<LI>integer, intent(in) :: mode 
<BR>
The access mode which the dataset should be used with. It must be one of the following values:
        
<UL>
<LI>READ Read an existing dataset with the given name. An error is
        raised if the dataset is not found, or cannot be opened.
</LI>
<LI>CREATE Create a new dataset with the given name. If an dataset
        already exisits with the given name, the behaviour is dependent on the
        setting of the environment variable SAS_FORMAT. Any changes made to
        the dataset will be discarded upon closure,
</LI>
<LI>MODIFY Open an existing dataset with the given name. All changes
        made to the dataset will be written saved upon closure.
</LI>
<LI>TEMP Open a new dataset. The dataset is discarded upon closure.
        
</LI>
</UL>
</LI>
<LI>integer, intent(in), optional :: memoryModel 
<BR>
This specifies a hint to which the memory model should be used. The following values are possible:
        
<UL>
<LI>HIGH_MEMORY 
</LI>
<LI>HIGH_LOW_MEMORY
</LI>
<LI>LOW_MEMORY
</LI>
<LI>USE_ENVIRONMENT
        
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataSetT) :: dataSet 
<BR>
A handle to the new dataset.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
This is a fundamental routine within the DAL API. Virtually all
        programs requiring the DAL will need to call this function to gain
        access to a dataset.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examp,e shows how to use the dataset
! function.
program example_dataset

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1", 10, "mm", "attribute comment" )
  call release(set)

  set = dataSet("test.dat",MODIFY)
  call setAttribute(set,"att1", 10, "mm", "attribute comment" )
  call release(set)

  set = dataSet("test.dat",READ)
  write(*,*) "att1 = ", int32Attribute( set, "att1" )
  call release(set)

end program example_dataset
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:clone"><TT>clone</TT></A>
        <A HREF="#func:f90:release"><TT>release</TT></A>
        <A HREF="#func:f90:setexists"><TT>setexists</TT></A>
        HIGH_MEMORY 
        HIGH_LOW_MEMORY 
        LOW_MEMORY 
        USE_ENVIRONMENT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>dataType</TT><A NAME="func:f90:dataType"></A><A NAME="6165"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the data type of an object.
</LI>
<LI>INTERFACE 
<BR>
function arrayDataType( array ) 
<BR>
function columnData( column ) 
<BR>
function dataComponent( dataComponent ) 
<BR>
function attributeDataType( attribute ) 
<BR>
function arrayAttributeDataTypeN( array, name ) 
<BR>
function arrayAttributeDataTypeR( array, number ) 
<BR>
function attributableAttributeDataTypeN( attributable, name ) 
<BR>
function attributableAttributeDataTypeR( attributable, number ) 
<BR>
function blockAttributeDataTypeN( block, name ) 
<BR>
function blockAttributeDataTypeR( block, number ) 
<BR>
function columnAttributeDataTypeN( column, name ) 
<BR>
function columnAttributeDataTypeR( column, number ) 
<BR>
function dataSetAttributeDataTypeN( dataSet, name ) 
<BR>
function dataSetAttributeDataTypeR( dataSet, number ) 
<BR>
function tableAttributeDataTypeN( table, name ) 
<BR>
function tableAttributeDataTypeR( table, number ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
        A handle of the array whose data type is required, or a handle of the
        array object containing the attribute whose data type is required.
</LI>
<LI>type(AttributableT), intent(in) :: attributable
        A handle of the attributable object containing the attribute whose data type is required.
</LI>
<LI>type(AttributeT), intent(in) :: attribute
        A handle of the attribute whose data type is required.
</LI>
<LI>type(BlockT), intent(in) :: block
        A handle of the block object containing the attribute whose data type is required.
</LI>
<LI>type(ColumnT), intent(in) :: column
        A handle of the column whose data type is required, or a handle of the
        column object containing the attribute whose data type is required.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent
        A handle of the dataComponent whose data type is required.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet
        A handle of the dataset object containing the attribute whose data type is required.
</LI>
<LI>character(len=*), intent(in) :: name
        The name of the attribute whose data type is required.
</LI>
<LI>integer, intent(in) :: number
        The number of the attribute whose data type is required.
</LI>
<LI>type(TableT), intent(in) :: table
        A handle of the table object containing the attribute whose data type is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
        Data type of a column, array, or dataComponent; one of the following enumeration
        values will be returned: BOOLEAN, INTEGER8, INTEGER16, INTEHER32, REAL32, REAL64, STRING
        Data type of an attribute: one of the following enumeration values will
        be returned: INTEGER_ATTRIBUTE, REAL_ATTRIBUTE, STRING_ATTRIBUTE,
        BOOLEAN_ATTRIBUTE.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
This interface is used to get the data type of columns, arrays,
        dataComponents and attributes.
        For attributes, the interface allows an attribute object to be used
        directly, or to specified an attribute, by giving its name or
        number within an attributable object.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! two 3-dimensional arrays.
!
! It illustrates the use of the derived types DataSetT and ArrayT.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The first array is filled with unique data before the
! dataset is released (closed).
program example_addarray

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_addarray
! This examples show how the column() function is used.
! The column by name is used to get a column and rename it.
! The column by number is used to iterate over all
! columns in the table to output the name, type and units.
program example_column

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"col1",INTEGER32,units="m1",comment="in32 column")
  col = addColumn(tab,"col2",INTEGER32,units="m2",comment="in32 column")
  col = addColumn(tab,"col3",INTEGER32,units="m3",comment="in32 column")

  col = column( tab, "col2", MODIFY )
  call rename( col, "col4" )

  do i =0, numberOfColumns( tab ) - 1
    col = column( tab, i, READ )
    write(*,*) name( col ), columnDataType( col ), units( col )
  end do

  call release(set)

end program example_column
! This example illustrates the use of the dataComponent() function.
! The units of objects with data type BOOLEAN and STRING are meaningless
! and so are not displayed.
subroutine displayUnits( dcomponent )
  use dal
 
  implicit none

  type(DataComponentT) dcomponent
  integer dattype

  dattype = dataType( dcomponent )
  write(*,*) dattype
  if(dattype.eq.INTEGER8.or.dattype.eq.INTEGER16.or.dattype.eq.INTEGER32 &amp;
    .or.dattype.eq.REAL32.or.dattype.eq.REAL64) then
    write(*,*) units( dcomponent )
  end if

end subroutine displayUnits

program example_datacomponent

  use dal
  
  implicit none

  type(ArrayT) arr
  type(BlockT) blk
  type(ColumnT) col
  type(DataSetT) set
  type(TableT) tab
  integer i, j
  integer, dimension(3), parameter :: s = (/ 2,3,4 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))
  arr = addArray(set, "array1", INTEGER16, dimensions=s, units="klm" )
  arr = addArray(set, "array2", INTEGER32, dimensions=s, units="kla" )

  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, READ )
    if( blockType( blk ).eq.ARRAY_BLOCK ) then
      arr = array( set, name( blk ), READ )
      call displayUnits( dataComponent( arr ) )
    else
      tab = table( set, name( blk ) )
      do j = 0, numberOfColumns( tab ) - 1
        col = column( tab, j, READ )
        call displayUnits( dataComponent( col ) )
      end do
    end if
  end do
  call release(set)

end program example_datacomponent
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
DataSetT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare DataSet handles.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR>
See dataSet.
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:dataSet"><TT>dataSet</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>deleteAttribute</TT><A NAME="func:f90:deleteAttribute"></A><A NAME="6171"></A>
</LI>
<LI>PURPOSE 
<BR>
Delete an attribute.
</LI>
<LI>INTERFACE 
<BR>
subroutine deleteAttribute( attribute ) 
<BR>
subroutine deleteArrayAttributeWithName( array, name ) 
<BR>
subroutine deleteArrayAttributeWithNumber( array, attributeNumber ) 
<BR>
subroutine deleteAttribAttributeWithName( attributable, name ) 
<BR>
subroutine deleteAttribAttributeWithNumber( attributable, attributeNumber ) 
<BR>
subroutine deleteBlockAttributeWithName( block, name ) 
<BR>
subroutine deleteBlockAttributeWithNumber( block, attributeNumber ) 
<BR>
subroutine deleteColumnAttributeWithName( column, name ) 
<BR>
subroutine deleteColumnAttributeWithNumber( column, attributeNumber ) 
<BR>
subroutine deleteDataSetAttributeWithName( dataSet, name ) 
<BR>
subroutine deleteDatSetAttributeWithNumber( dataSet, attributeNumber ) 
<BR>
subroutine deleteTableAttributeWithName( table, name )
        subroutine deleteTableAttributeWithNumber( table, attributeNumber )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
The handle of an array from which the specified attribute should be deleted.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
The handle of an attributable from which the specified attribute should be deleted.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
The handle of an attribute to be deleted.
</LI>
<LI>type(AttributableT), intent(in) :: attributeNumber 
<BR>
The ordinal position ofthe attribute to delete.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
The handle of a block from which the specified attribute should be deleted.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
The handle of a column from which the specified attribute should be deleted.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
The handle of a dataset from which the aspecified ttribute should be deleted.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the attribute to be deleted.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table from which the specified attribute should be deleted.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Delete the given attribute or delete an attribute, with the given name
        or number, from the specified attributable (or a subclass of attributable) object.
        In the event that the attribute cannot be deleted an error will be raised.
        The DataSet, Table, Array, Block, Column and Table types are derived from the Attributæble type and hence may
        contain attributes.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the deleteAttribute inteface is
! used.
subroutine deleteAllAttributes( attrib )
  use dal
  implicit none

  type(AttributableT) attrib
  type(AttributeT) att
  integer i

  do i = 0, numberOfAttributes( attrib ) - 1
    att = attribute( attrib, 0 )
    write(*,*) "deleting attribute with name ", name( att )
    call deleteAttribute( att )
  end do

end subroutine deleteAllAttributes

program example_deleteattribute

  use dal
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
   
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.true.,"dataset bool comment")
  call setAttribute(set,"sbool3",.false.,"table bool comment")
  call setAttribute(set,"sbool4",.true.,"table bool comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"sbool1",.false.,"table bool comment")
  call setAttribute(tab,"sbool2",.true.,"table bool comment")
  call setAttribute(tab,"sbool3",.false.,"table bool comment")
  call setAttribute(tab,"sbool4",.true.,"table bool comment")

  write(*,*) numberOfAttributes( set )
  call deleteAllAttributes( attributable( set ) )
  write(*,*) numberOfAttributes( set )
  write(*,*) numberOfAttributes( tab )
  call deleteAllAttributes( attributable( tab ) )
  write(*,*) numberOfAttributes( tab )

  call release(set)
   
end program example_deleteattribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:attribut_ble"><TT>attributæble</TT></A>
        AttributableT 
        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        AttributeT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>deleteBlock</TT><A NAME="func:f90:deleteBlock"></A><A NAME="6180"></A>
</LI>
<LI>PURPOSE 
<BR>
Delete a block from a dataset.
</LI>
<LI>INTERFACE 
<BR>
subroutine deleteBlockWithName( dataSet, blockName ) 
<BR>
subroutine deleteBlockWithNumber( dataSet, blockNumber )
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: blockName 
<BR>
The name of the block to be deleted.
</LI>
<LI>integer, intent(in) :: blockNumber 
<BR>
The ordinal position of the block to be deleted.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
The handle of a dataset from which the block should be deleted.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Delete a block wth the given name or number from the specified dataset.
        In the event that the block cannot be deleted an error will be raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the deleteBlock interface
! is used.
program example_deleteblock

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(BlockT) blk
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table1",10)
  tab = addTable(set,"table2",100)
  tab = addTable(set,"table3",1000)

  write(*,*) numberOfBlocks( set )

  call deleteBlock( set, "table2" );

  do i=0,numberOfBlocks( set ) - 1
    blk = block( set, 0, READ )
    write(*,*) "deleting block with name ", name( blk )
    call deleteBlock( set, 0 )
  end do

  write(*,*) numberOfBlocks( set )

  call release(set)

end program example_deleteblock
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addBlock"><TT>addBlock</TT></A>
        BlockT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>deleteColumn</TT><A NAME="func:f90:deleteColumn"></A><A NAME="6186"></A>
</LI>
<LI>PURPOSE 
<BR>
Delete a column from a table.
</LI>
<LI>INTERFACE 
<BR>
subroutine deleteColumnWithName( table, columnName ) 
<BR>
subroutine deleteColumnWithNumber( table, columnNumber )
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: columnName 
<BR>
The name of the column to be deleted.
</LI>
<LI>integer, intent(in) :: columnNumber 
<BR>
The ordinal position of the column to be deleted.
</LI>
<LI>type( TableT ), intent(in) :: table 
<BR>
The handle of a table from which the column should be deleted.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Delete a column wth the given name or number from the specified table.
        In the event that the column could not be deleted an error is raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
program example_addcolumn

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))

  call deleteColumn( tab, "int32" )
  call deleteColumn( tab, 3 ) ! "real32"

  do i = 0, numberOfColumns( tab ) - 1
    write(*,*) name( column( tab, i, READ ) )
  end do

  call release(set)

end program example_addcolumn
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>deleteRows</TT><A NAME="func:f90:deleteRows"></A><A NAME="6189"></A>( table, from, count )
</LI>
<LI>PURPOSE 
<BR>
Delete a range of rows from a table.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table within which the specified range of rows should be deleted.
</LI>
<LI>integer, intent(in) :: from 
<BR>
The first row number of the range. 0 &lt;= from &lt; n, where n is the number of rows in the table.
</LI>
<LI>integer, intent(in), optional :: count 
<BR>
The number of rows in the range. 0 &lt;= count &lt; n ,where n is the number of rows in the table.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
This operation is very expensive. The range is specified with couple [from,count], where from + count &lt;= n, where n is the number of rows in the table.
        It should be carefully noted that any data pointers (to columns in this
        table) which are currently active
        will become stale after deleteRows() has been called.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how to use the deleteRows() subroutine. 
program example_deleterows

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=single), dimension(:), pointer :: r32
  integer i, r

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",10)

  col1 = addColumn(tab,"col1",INTEGER32,units="m",comment="in32 column")
  i32 =&gt; int32Data(col1)

  do i=0,4
    i32(i) = 3*i
  end do

  call release( col1)

  col2 = addColumn(tab,"col2",REAL32,units="Dm",comment="real32 column")
  r32 =&gt; real32Data(col2)

  do i=0,4
    r32(i) = 0.5*i
  end do

  call release( col2)

  call copyRows( tab, 0, 5, 5 ) ! copy range [0,4] to [5,9]

  i32 =&gt; int32Data(col1)
  r32 =&gt; real32Data(col2)

  do i = 0, numberOfRows( tab ) - 1
    write(*,*) i32(i), r32(i) 
  end do

  call release(col1)
  call release(col2)

  r = 0
  do i = 0, 9
    i32 =&gt; int32Data(col1)
    if( i32(r) .eq. 6 ) then
      write(*,*) "deleting row number ", i
      call deleteRows( tab, r, 1 )
    else
      r = r + 1
    end if
    call release( col1 )
  end do

  i32 =&gt; int32Data(col1)
  r32 =&gt; real32Data(col2)
  do i = 0, numberOfRows( tab ) - 1
    write(*,*) i32(i), r32(i) 
  end do


  call release(set)

end program example_deleterows
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:copyRows"><TT>copyRows</TT></A>
        <A HREF="#func:f90:insertRows"><TT>insertRows</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>discardDataSet</TT><A NAME="func:f90:discardDataSet"></A><A NAME="6198"></A>
</LI>
<LI>PURPOSE 
<BR>
Tells the data set server object to discard the named data set.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: dataSetName 
<BR>
The name of the dataset.
</LI>
</UL>
</LI>
<LI>RETURNS  
<BR>
None 
</LI>
<LI>DESCRIPTION 
<BR>
The named data set is released from memory.

<P>
This subroutine must only be called by Meta Tasks.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the keepDataSet
! subroutine
program example_keepdiscarddataset

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet("test.dat",CREATE)
  call release(set)		  ! The dataset will be released from memory

  call keepDataSet("test.dat")	  ! Tell the dataset server not to discard
  				  ! the dataset with name "test.dat"

  set = dataSet("test.dat",READ)
  call release(set)		  ! The dataset will not be released from memory

  set = dataSet("test.dat",READ)  ! The dataset is already in memory, so this
  				  ! operation has virtually no overhead.

  call release(set)		  ! The dataset will not be released from memory
  call discardDataSet("test.dat") ! Tell the dataset server to discard and
  				  ! release the dataset with name "test.dat"

end program example_keepdiscarddataset
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:keepDataSet"><TT>keepDataSet</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>dimensions</TT><A NAME="func:f90:dimensions"></A><A NAME="6204"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the dimensions of an array or a column.
</LI>
<LI>INTERFACE 
<BR>
function dimensionsOfArray( array ) 
<BR>
function dimensionsOfColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type( ArrayT ), intent(in) :: array 
<BR>
The handle of an array from which the dimensions are to be retrieved.
</LI>
<LI>type( ColumnT ), intent(in) :: column 
<BR>
The handle of a column from which the dimensions are to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer, dimension(:), pointer 
<BR>
The number of elements in the returned vector gives the rank of the
        objects data. Each element of the returned vector gives the length of each dimension.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example demonstrates the dimensions inteferface.

subroutine fillWithData( dataSetName )

  use dal

  implicit none

  character(len=*), intent(in) :: dataSetName
  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer(kind=INT32), dimension(:,:,:,:,:), pointer :: c
  integer, dimension(:), pointer :: s
  integer :: i,j,k,l,m,n

  ! Reopen dataset and fill with data.
  set = dataSet( dataSetName, MODIFY )
  tab = table( set, "table" )
  col = column( tab, "column", MODIFY )
  s =&gt; dimensions( col )
  c =&gt; int32Array4Data( col )

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0, s(3) - 1
      do k=0, s(2) - 1
        do j=0, s(1) - 1
          do i=0, s(0) - 1
            c(i,j,k,l,m) = n
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col)
  call release(set)

end subroutine fillWithData

program example_dimensions

  use dal

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col = addColumn( tab, "column", INTEGER32, "km", s, "column comment" )
  call release( set )

  call fillWithData( "test.dat" )

end program example_dimensions
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
DOUBLE
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate real data of double
        precision.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>forEachBlock</TT><A NAME="func:f90:forEachBlock"></A><A NAME="6207"></A>( dataSet, callThisFunction )
</LI>
<LI>PURPOSE 
<BR>
Block iteration.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
The handle of a dataset for which block iteration is to be carried
        out.
</LI>
<LI>interface
                subroutine callThisFunction( block )
                        type(BlockT), intent(in) :: block
                end subroutine callThisFunction
        end interface 
<BR>
The iterating function to be called for each block in the dataset. The
        block is passed by handle to the iterating function.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
Call the specified subroutine for each block, in turn, in the specified
        dataset.
        If the dataset has no blocks, no iteration will be attempted. Each
        block is passed to the iterating subroutine as a block-handle.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example, a dataset is created with one table and one
! array.
! The generic subroutine displayBlock, which operates on the
! BlockT base type. The blockType() function operates on objects
! of type BlockT.
! The example also shows blocks being retrieved from the dataset
! both by name and by number.
subroutine displayBlock( thisBlock )
  use dal

  implicit none

  type(BlockT), intent(in) ::  thisBlock

  write(*,*) "The block with name ", name( thisBlock )

  if( blockType( thisBlock ) .eq. ARRAY_BLOCK ) then
    write(*,*) " is an array."
  end if

  if( blockType( thisBlock ) .eq. TABLE_BLOCK ) then
    write(*,*) " is a table."
  end if

end subroutine displayBlock

subroutine displayBlocks( thisSet )
  use dal

  implicit none

  type(DataSetT) thisSet
  integer i

  interface
    subroutine displayBlock( blk )
      use dal
      implicit none
      type(BlockT), intent(in) :: blk

    end subroutine displayBlock
  end interface
  call foreachblock( thisSet, displayBlock )

end subroutine displayBlocks

program example_foreachblock
   
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table",10);
  arr = addArray(set, "array", INTEGER32, dimensions=s )

  call displayBlock( block( tab ) )
  call displayBlock( block( arr ) )
  call displayBlock( block( set, "table", READ ) )
  call displayBlock( block( set, "array", READ ) )
  call displayBlocks( set )

  call release(set)
   
end program example_foreachblock
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
BlockT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>forEachColumn</TT><A NAME="func:f90:forEachColumn"></A><A NAME="6210"></A>( table, callThisFunction )
</LI>
<LI>PURPOSE 
<BR>
Column iteration.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table fro which column iteration is to be
        carried out.
</LI>
<LI>interface
                subroutine callThisFunction( column )
                        type(TableT), intent(in) :: column
                end subroutine callThisFunction
        end interface 
<BR>
The iterating function to be called for each column in the table. Each
        column is passed to the iterating subroutine as a column-handle.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how the forEachColumn() function is used.
! The column by name is used to get a column and rename it.
! The column by number is used to iterate over all
! columns in the table to output the name, type and units.
subroutine displayColumn( col )

  use dal

  implicit none

  type(ColumnT), intent(in) :: col

  write(*,*) name( col ), columnDataType( col ), units( col )

end subroutine displayColumn

program example_foreachcolumn

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  interface
    subroutine displayColumn( col )
      use dal
      implicit none

      type(ColumnT), intent(in) :: col
    end subroutine displayColumn
  end interface

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"col1",INTEGER32,units="m1",comment="in32 column")
  col = addColumn(tab,"col2",INTEGER32,units="m2",comment="in32 column")
  col = addColumn(tab,"col3",INTEGER32,units="m3",comment="in32 column")

  col = column( tab, "col2", MODIFY )
  call rename( col, "col4" )

  call forEachColumn( tab, displayColumn )
  call release(set)

end program example_foreachcolumn
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
ColumnT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>forEachSubTable</TT><A NAME="func:f90:forEachSubTable"></A><A NAME="6213"></A>( table, callThisFunction )
</LI>
<LI>PURPOSE 
<BR>
Subtable iteration.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table for which subtable iteration is to be carried
        out.
</LI>
<LI>interface
                subroutine callThisFunction( subTable )
                        type(TableT), intent(in) :: subTable
                end subroutine callThisFunction
        end interface 
<BR>
The iterating subroutine to be called for each subtable of the table.
        The iterating subroutine is passed the subtable as a subtable-hnadle.
        The table size is dependent on the model. In, the High Memory Mode,
        the entire table is passed to the iterating function, which therefore
        is called only once.
        In the Low Memory Mode, the table size defaults to 1 row, but may be
        changed by setting the environment variable SAS_ROWS to the required
        table size. The Memory Model is set with the environment variable
        SAS_MEMORY_MODEL.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the forEachSubTable() function
! is used.
! This subroutine will fill the subtable with dummy data.
subroutine fill(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: xCol, yCol, tCol
  real(kind=SINGLE), dimension(:), pointer :: x,y,t

  write(*,*) from( tab ), count( tab )

  xCol = column(tab,"x",MODIFY)
  yCol = column(tab,"y",MODIFY)
  tCol = column(tab,"t",MODIFY)
  x =&gt; real32Data(xCol)
  x = 1.23
  write(*,*) x
  y =&gt; real32Data(yCol)
  y = 2.34
  write(*,*) y
  t =&gt; real32Data(tCol)
  t = 3.45
  write(*,*) t

end subroutine fill

! This subroutine will write the contents of the subtable to standard output.
subroutine check(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: xCol, yCol, tCol
  real(kind=single), dimension(:), pointer :: x,y,t

  write(*,*) from( tab ), count( tab )

  xCol = column(tab,"x",READ)
  yCol = column(tab,"y",READ)
  tCol = column(tab,"t",READ)
  x =&gt; real32Data(xCol)
  y =&gt; real32Data(yCol)
  t =&gt; real32Data(tCol)
  write(*,*) "DATA:", x, y, t

end subroutine check

program example_foreachsubtable

  use dal

  implicit none

  ! This part of the program will apply reportX to a table. 
  type(DataSetT) :: set
  type(TableT) :: tab
  type(ColumnT) :: xCol, yCol, tCol
  real(kind=SINGLE), dimension(:), pointer :: x,y,t

  interface
    subroutine fill( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine fill
    subroutine check( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine check
  end interface

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"events",10)
  xCol = addColumn(tab,"x",real32,"mm")
  yCol = addColumn(tab,"y",real32,"mm")
  tCol = addColumn(tab,"t",real32,"s")

  call forEachSubTable(tab,fill)
  call forEachSubTable(tab,check)

  call release(set)

end program example_foreachsubtable
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:foreachBlock"><TT>foreachBlock</TT></A>
        <A HREF="#func:f90:forEachColumn"><TT>forEachColumn</TT></A>
        <A HREF="#func:f90:forEachRow"><TT>forEachRow</TT></A>
        SubtableT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>forEachRow</TT><A NAME="func:f90:forEachRow"></A><A NAME="6225"></A>( table, fn )
</LI>
<LI>PURPOSE 
<BR>
Row iteration.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table for which subtable iteration is required.
</LI>
<LI>interface
                subroutine fn( r )
                        type(RowT), intent(in) :: r
                end subroutine
        end interface 
<BR>
The iterating subroutine which be will be called for each row in the table;
        the row being passed as a row-handle.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the forEachSubTable() function
! is used.
! This subroutine will fill the subtable with dummy data.
subroutine fill(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: xCol, yCol, tCol
  real(kind=SINGLE), dimension(:), pointer :: x,y,t

  xCol = column(tab,"x",MODIFY)
  yCol = column(tab,"y",MODIFY)
  tCol = column(tab,"t",MODIFY)
  x =&gt; real32Data(xCol)
  x = 1.23
  y =&gt; real32Data(yCol)
  y = 2.34
  t =&gt; real32Data(tCol)
  t = 0

end subroutine fill

! This subroutine will write the contents of the subtable to standard output.
subroutine check(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: xCol, yCol, tCol
  real(kind=single), dimension(:), pointer :: x,y,t

  xCol = column(tab,"x",READ)
  yCol = column(tab,"y",READ)
  tCol = column(tab,"t",READ)
  x =&gt; real32Data(xCol)
  y =&gt; real32Data(yCol)
  t =&gt; real32Data(tCol)
  write(*,*) x, y, t

end subroutine check

program example_foreachsubtable

  use dal

  implicit none

  ! This part of the program will apply reportX to a table. 
  type(DataSetT) :: set
  type(TableT) :: tab
  type(ColumnT) :: xCol, yCol, tCol
  real(kind=SINGLE), dimension(:), pointer :: x,y,t

  interface
    subroutine fill( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine fill
    subroutine check( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine check
  end interface

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"events",10)
  xCol = addColumn(tab,"x",real32,"mm")
  yCol = addColumn(tab,"y",real32,"mm")
  tCol = addColumn(tab,"t",real32,"s")

  call forEachRow(tab,fill)
  call forEachRow(tab,check)

  call release(set)

end program example_foreachsubtable
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>from</TT><A NAME="func:f90:from"></A><A NAME="6228"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the from-value from the seek range of an object.
</LI>
<LI>INTERFACE 
<BR>
function fromColumn( column )
        function fromTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>type(TableT), intent(in) :: table
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the seek functions
! are used.
! This subroutine will dispaly the seek values of the given table and column.
subroutine whatisseek(tab)
  use dal

  type(TableT), intent(in) :: tab

  type(ColumnT) :: col

  write(*,*) from( tab ), count( tab )

  col = column(tab,"x",MODIFY)
  write(*,*) from( col ), count( col )

end subroutine whatisseek

program example_seek

  use dal

  implicit none

  type(DataSetT) :: set
  type(TableT) :: tab
  type(ColumnT) :: col

  interface
    subroutine whatisseek( subtab )
      use dal
      implicit none
      type(TableT), intent(in) :: subtab
    end subroutine whatisseek
  end interface

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"events",10)
  col = addColumn(tab,"x",real32,"mm")

  call forEachSubTable(tab,whatisseek)

  call release(set)

end program example_seek
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:count"><TT>count</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>hasAttribute</TT><A NAME="func:f90:hasAttribute"></A><A NAME="6234"></A>
</LI>
<LI>PURPOSE 
<BR>
Determine if an attribute with a given name exists.
</LI>
<LI>INTERFACE 
<BR>
function arrayHasAttribute( array, name ) 
<BR>
function attributableHasAttribute( attributable, name ) 
<BR>
function blockHasAttribute( block, name ) 
<BR>
function columnHasAttribute( column, name ) 
<BR>
function dataSetHasAttribute( dataSet, name ) 
<BR>
function tableHasAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
The handle of an array which is to be tested for the existence of the attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
The handle of an attributable which is to be tested for the existence of the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
The handle of a block which is to be tested for the existence of the attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
The handle of a column which is to be tested for the existence of the attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
The handle of a dataset which is to be tested for the existence of the attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table which is to be tested for the existence of the attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Determine if an attribute with the given name exists within the given
        attributable set.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shoes how the hasAttribute interface is used.
program example_hasattribute

  use dal
  implicit none
   
  type(DataSetT) set
  type(AttributeT) att

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")

  if( hasAttribute( set, "sbool2" ) ) then
    write(*,*) 'That is not possible'
  end if

  if( hasAttribute( set, "sbool1" ) ) then
    att = attribute( set, "sbool1" )
    write(*,*) name( att ), " = ", booleanAttribute( att )
  end if

  call release(set)
   
end program example_hasattribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
AttributableT 
        AttributeT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>hasBlock</TT><A NAME="func:f90:hasBlock"></A><A NAME="6237"></A>( set, name )
</LI>
<LI>PURPOSE 
<BR>
Determine if a block with a given name exists.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: set 
<BR>
The handle of the dataset which is to be examined for the existence of
        the named block.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the block.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Block names are unique within a dataset, so there can never be more
        than one block with the given name. If a block with the given name is not
        found, false is returned, otherwise true is returned.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example showas how the hasBlock() function is used.
! In the example, a dataset is created with one table and one
! array.
! The generic subroutine displayBlock, which operates on the
! BlockT base type. The blockType() function operates on objects
! of type BlockT.
! The dataset is testes for the existence of the table and the array, and in
! each case, the block is displayed.
subroutine displayBlock( thisBlock )
  use dal

  implicit none

  type(BlockT) thisBlock

  write(*,*) "The block with name ", name( thisBlock )

  if( blockType( thisBlock ) .eq. ARRAY_BLOCK ) then
    write(*,*) " is an array."
  end if

  if( blockType( thisBlock ) .eq. TABLE_BLOCK ) then
    write(*,*) " is a table."
  end if

end subroutine displayBlock

program example_hasblock
   
  use dal

  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table",10);
  arr = addArray(set, "array", INTEGER32, dimensions=s )

  call release(set)

  set = dataSet("test.dat",READ)

  if( hasBlock( set, "table" ) ) then
    call displayBlock( block( set, "table",READ ) )
  end if

  if( hasBlock( set, "array" ) ) then
    call displayBlock( block( set, "array",READ ) )
  end if

  call release(set)
   
end program example_hasblock
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
BlockT 
        DataSetT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>hasColumn</TT><A NAME="func:f90:hasColumn"></A><A NAME="6240"></A>( table, name )
</LI>
<LI>PURPOSE 
<BR>
Determine if a column with a given name exists.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of the table which is to be examined for the existence of
        the named column.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the column.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
Determine if a column with a given name exists within the given table.
        Column names are unique, within a table, so there can never be more
        than one column with the given name.
        False is returned if a column the given name is not found, otherwise
        true is returned.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how the hasColumn() function is used.
! The column by name is used to get a column and rename it.
! The column by number is used to iterate over all
! columns in the table to output the name, type and units.
program example_hascolumn

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"col1",INTEGER32,units="m1",comment="in32 column")
  col = addColumn(tab,"col2",INTEGER32,units="m2",comment="in32 column")
  col = addColumn(tab,"col3",INTEGER32,units="m3",comment="in32 column")

  col = column( tab, "col2", MODIFY )
  call rename( col, "col4" )

  if( hasColumn( tab, "col2" ) ) then
    write(*,*) 'This is not possible, since col4 was renamed to col4'
  end if

  do i =0, numberOfColumns( tab ) - 1
    col = column( tab, i, READ )
    write(*,*) name( col ), columnDataType( col ), units( col )
  end do

  call release(set)

end program example_hascolumn
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>hasNulls</TT><A NAME="func:f90:hasNulls"></A><A NAME="6243"></A>
</LI>
<LI>PURPOSE 
<BR>
Determines if an object contains any null values.
</LI>
<LI>INTERFACE 
<BR>
function hasNullArray( array ) 
<BR>
function hasNullColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the values to be checked.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the values to be checked.
</LI>
<LI>integer(kind=INT32), intent(in) :: position 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR>
True, if a null value was found, false otherwise.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
This routine searches for null values in the specified object (a column or an
array). 
Note that if the LMM is being used, the object's data is first
loaded into memory before the cjheck is carried out, and is then released
again.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>hasScaling</TT><A NAME="func:f90:hasScaling"></A><A NAME="6270"></A>
</LI>
<LI>PURPOSE 
<BR>
THIS INTERFACE IS NOT IMPLEMENTED.
        Determine if scaling factors have been set for an array or a column.
</LI>
<LI>INTERFACE 
<BR>
function hasScalingOfArray( array ) 
<BR>
function hasScalingOfColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
N/A
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
HIGH_MEMORY
</LI>
<LI>PURPOSE 
<BR>
An enumeration value used to specify that the High Memory Model should be used to open a
        dataset.
</LI>
<LI>DESCRIPTION 
<BR>
This is a hint only, and may be overridden using an environment
        variable setting.
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This examp,e shows how to open a dataset
! with a specific memory model.
program example_memorymodel

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet( "test.dat",CREATE,HIGH_MEMORY )
  call release( set )

  set = dataSet( "test.dat",HIGH_LOW_MEMORY )
  call release( set )

end program example_memorymodel
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
HIGH_LOW_MEMORY 
        LOW_MEMORY
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
HIGH_LOW_MEMORY
</LI>
<LI>PURPOSE 
<BR>
An enumeration value used to specify that the highlow memory model should be used to open a
        dataset.
</LI>
<LI>DESCRIPTION 
<BR>
This is a hint only, and may be overridden using an environment
        variable setting.
</LI>
<LI>EXAMPLES 
<BR><PRE>
! This examp,e shows how to open a dataset
! with a specific memory model.
program example_memorymodel

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet( "test.dat",CREATE,HIGH_MEMORY )
  call release( set )

  set = dataSet( "test.dat",HIGH_LOW_MEMORY )
  call release( set )

end program example_memorymodel
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
HIGH_MEMORY
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>insertRows</TT><A NAME="func:f90:insertRows"></A><A NAME="6273"></A>( table, position, count )
</LI>
<LI>PURPOSE 
<BR>
Insert a range of rows in a table.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR>
The handle of a table within which the specified range of rows should be inserted. 
</LI>
<LI>integer, intent(in) :: position 
<BR>
This specifies at which row to insert the range of rows, which must be
        in the range 0 to n, where n is the number of rows in the table.
</LI>
<LI>integer, intent(in), optional :: count 
<BR>
The nunber of rows to be inserted.
</LI>
</UL>
</LI>
<LI>RETURNS
        None
</LI>
<LI>DESCRIPTION 
<BR>
This operation is very expensive and should be used minimally.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples show how to use the insertRows() subroutine. 
program example_insertrows

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=single), dimension(:), pointer :: r32
  integer i, r

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",5)

  col1 = addColumn(tab,"col1",INTEGER32,units="m",comment="in32 column")
  i32 =&gt; int32Data(col1)

  do i=0,4
    i32(i) = 3*i
  end do

  call release( col1)

  col2 = addColumn(tab,"col2",REAL32,units="Dm",comment="real32 column")
  r32 =&gt; real32Data(col2)

  do i=0,4
    r32(i) = 0.5*i
  end do

  call release( col2)

  ! insert 5 additional rows, at the end of the table
  call insertRows( tab, 5, 5 )

  ! copy the first 5 rows to the new rows.
  call copyRows( tab, 0, 5, 5 ) ! copy range [0,4] to [5,9]

  i32 =&gt; int32Data(col1)
  r32 =&gt; real32Data(col2)

  do i = 0, numberOfRows( tab ) - 1
    write(*,*) i32(i), r32(i) 
  end do

  call release(col1)
  call release(col2)

  r = 0
  do i = 0, 9
    i32 =&gt; int32Data(col1)
    if( i32(r) .eq. 6 ) then
      write(*,*) "deleting row number ", i
      call deleteRows( tab, r, 1 )
    else
      r = r + 1
    end if
    call release( col1 )
  end do

  i32 =&gt; int32Data(col1)
  r32 =&gt; real32Data(col2)

  do i = 0, numberOfRows( tab ) - 1
    write(*,*) i32(i), r32(i) 
  end do


  call release(set)

end program example_insertrows
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:copyRows"><TT>copyRows</TT></A>
        <A HREF="#func:f90:deleteRows"><TT>deleteRows</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INT8
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate int8 data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array2Data</TT><A NAME="func:f90:int8Array2Data"></A><A NAME="6282"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from an array or column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray2DataElement( column, row ) 
<BR>
function int8ArrayArray2Data( array )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array for which the data is to be retrieved.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column for which the data is to be retrieved.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The column row number (cell number) for which the data is to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; int8Array2Data(col1,k)
    c2 =&gt; int8Array2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = n
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT8), dimension(:,:), pointer :: a1, a2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER8, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER8, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int8Array2Data(arr1)
  a2 =&gt; int8Array2Data(arr2)
  do j=0,3
    do i=0,2 
      a1(i,j) = n
      a2(i,j) = a1(i,j)
      n = n + 1
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array2Data</TT><A NAME="func:f90:int8Array2Data"></A><A NAME="6285"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:,:), pointer 
<BR>
The 2-dimensional data is returned as a 3-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned as a 3-dimensional array, since the column's data
        is arranged as a vector of 2-dimensional elements.
        The column should be released after the data is no longer required.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int8Array2Data(col1)
  c2 =&gt; int8Array2Data(col2)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = n
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array3Data</TT><A NAME="func:f90:int8Array3Data"></A><A NAME="6288"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from an array or column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray3DataElement( column, row ) 
<BR>
function int8ArrayArray3Data( array )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array which contains the data to be retrieved.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be retrieved.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The column row number (cell number) for which the data is to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; int8Array3Data(col1,l)
    c2 =&gt; int8Array3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = n
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT8), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER8, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER8, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int8Array3Data(arr1)
  a2 =&gt; int8Array3Data(arr2)
  do k=0,4
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array3Data</TT><A NAME="func:f90:int8Array3Data"></A><A NAME="6291"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from a column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:,:,:), pointer 
<BR>
The 2-dimensional data is returned as a 4-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned as a 4-dimensional array, since the column's data
        is arranged as a vector of 3-dimensional elements.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int8Array3Data(col1)
  c2 =&gt; int8Array3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = n
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array4Data</TT><A NAME="func:f90:int8Array4Data"></A><A NAME="6294"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be retrieved.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The column row number (cell number) which contains the data to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int8Array4Data(col1,m)
    c2 =&gt; int8Array4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = n
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8Array4Data</TT><A NAME="func:f90:int8Array4Data"></A><A NAME="6297"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnArray4Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the data is to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:,:,:,:), pointer 
<BR>
The 5-dimensional data is returned as a 4-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned as a 5-dimensional array, since the column's data
        is arranged as a vector of 4-dimensional elements.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int8Array4Data(col1)
  c2 =&gt; int8Array4Data(col1)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>int8Attribute</TT><A NAME="func:f90:int8Attribute"></A><A NAME="6308"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as an int8.
</LI>
<LI>INTERFACE 
<BR>
function int8ArrayAttribute( array, name ) 
<BR>
function int8AttributableAttribute( attributable, name ) 
<BR>
function int8Attribute( attribute ) 
<BR>
function int8BlockAttribute( Block, name ) 
<BR>
function int8ColumnAttribute( column, name ) 
<BR>
function int8DataSetAttribute( dataSet, name ) 
<BR>
function int8TableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of the attributable containing the required attribute.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block  
<BR>
A handle of the block containing the required attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of the column containing the required attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the required attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of the table containing the required attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8) 
<BR>
The attribute's internal value is returned as an int8-integer (type conversion
taking place, if possible, as necessary).
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
In the event that the attribute's value cannot be type converted an
        error is raised.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how int8 attributes are used.
! The program creates a dataset containing two int8 attributes,
! together with a table containing two int8 attributes.
! The attributes are then accessed, by name, with
! the int8Attribute() function.
! Also, it is shown how to access the attributes by position.
program example_int8attribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"int1",1,"int comment")
  call setAttribute(set,"int2",2,"int comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"int1",3,"int comment")
  call setAttribute(tab,"int2",4,"int comment")

  write(*,*) int8Attribute( set, "int1" ) ! output '1'
  write(*,*) int8Attribute( set, "int2" ) ! output '2'
  write(*,*) int8Attribute( tab, "int1" ) ! output '3'
  write(*,*) int8Attribute( tab, "int2" ) ! output '4'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) int8Attribute( att ) ! output the sequence 1, 2
  end do

  call release(set)

end program example_int8attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>int8Data</TT><A NAME="func:f90:int8Data"></A><A NAME="6319"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function int8ArrayData( array ) 
<BR>
function int8ColumnData( column ) 
<BR>
function int8ColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:), pointer 
<BR>
The data is returned as a flat vector regardless of the dimensionality of the
data.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned in a vector regardles of the dimensionality of the data. In particular, when accessing a scalar column cell, a vector of length 1 is returned, which contains the single scalar value.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_int8data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:,:,:,:), pointer :: c1, c2
  integer(kind=INT8), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int8Array4Data(col1)
  c2 =&gt; int8Array4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; int8Data( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_int8data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>int8VectorData</TT><A NAME="func:f90:int8VectorData"></A><A NAME="6330"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from an array or column cell containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int8ArrayVectorData( array ) 
<BR>
function int8ColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int8VectorData(col1,m)
    c2 =&gt; int8VectorData(col2,m)
    do i=0,2 
      c1(i) = n
      c2(i) = c1(i)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellvectordata
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The array is then initialised,
program example_arrayvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT8), dimension(:), pointer :: a1, a2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER8, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER8, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int8VectorData(arr1)
  a2 =&gt; int8VectorData(arr2)
  do i=0,2 
    a1(i) = n
    a2(i) = a1(i)
    n = n + 1
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int8VectorData</TT><A NAME="func:f90:int8VectorData"></A><A NAME="6333"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int8 data from a column containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int8ColumnVectorData( column ) result( ptr )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The column must contain vector data.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second column has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT8), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 10, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER8, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int8VectorData(col1)
  c2 =&gt; int8VectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = n
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INT16
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate that integer16 data is being
used.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array2Data</TT><A NAME="func:f90:int16Array2Data"></A><A NAME="6336"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from an array or column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ArrayArray2Data( array ) 
<BR>
function int16ColumnArray2DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array which contains the data to be accessed.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The number of the column cell which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the int16Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; int16Array2Data(col1,k)
    c2 =&gt; int16Array2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = n
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
! This example shows how to use the int16Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT16), dimension(:,:), pointer :: a1, a2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER16, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER16, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int16Array2Data(arr1)
  a2 =&gt; int16Array2Data(arr2)
  do j=0,3
    do i=0,2 
      a1(i,j) = n
      a2(i,j) = a1(i,j)
      n = n + 1
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array2Data</TT><A NAME="func:f90:int16Array2Data"></A><A NAME="6339"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column which contains the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:,:), pointer 
<BR>
The 2-dimensional data is returned as a 3-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int16Array2Data(col1)
  c2 =&gt; int16Array2Data(col2)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = n
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array3Data</TT><A NAME="func:f90:int16Array3Data"></A><A NAME="6342"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from an array or column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ArrayArray3Data( array ) 
<BR>
function int16ColumnArray3DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; int16Array3Data(col1,l)
    c2 =&gt; int16Array3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = n
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT16), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER16, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER16, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int16Array3Data(arr1)
  a2 =&gt; int16Array3Data(arr2)
  do k=0,4
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array3Data</TT><A NAME="func:f90:int16Array3Data"></A><A NAME="6345"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:,:,:), pointer 
<BR>
The 3-dimensional data is returned as a 4-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int16Array3Data(col1)
  c2 =&gt; int16Array3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = n
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array4Data</TT><A NAME="func:f90:int16Array4Data"></A><A NAME="6348"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:,:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int16Array4Data(col1,m)
    c2 =&gt; int16Array4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = n
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Array4Data</TT><A NAME="func:f90:int16Array4Data"></A><A NAME="6351"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int16ColumnArray4Data( column ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:,:,:,:), pointer 
<BR>
The 4-dimensional column data is returned as a 5-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int16Array4Data(col1)
  c2 =&gt; int16Array4Data(col1)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Attribute</TT><A NAME="func:f90:int16Attribute"></A><A NAME="6354"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as an int16.
</LI>
<LI>INTERFACE 
<BR>
function int16ArrayAttribute( array, name ) 
<BR>
function int16AttributableAttribute( attributable, name ) 
<BR>
function int16Attribute( attribute ) 
<BR>
function int16BlockAttribute( Block, name ) 
<BR>
function int16ColumnAttribute( column, name ) 
<BR>
function int16DataSetAttribute( dataSet, name ) 
<BR>
function int16TableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of the attributable containing the required attribute.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of the block containing the required attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of the dataset containing the required attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the required attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of the table containing the required attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how int16 attributes are used.
! The program creates a dataset containing two int16 attributes,
! together with a table containing two int16 attributes.
! The attributes are then accessed, by name, with
! the int16Attribute() function.
! Also, it is shown how to access the attributes by position.
program example_int16attribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"int1",1,"int comment")
  call setAttribute(set,"int2",2,"int comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"int1",3,"int comment")
  call setAttribute(tab,"int2",4,"int comment")

  write(*,*) int16Attribute( set, "int1" ) ! output '1'
  write(*,*) int16Attribute( set, "int2" ) ! output '2'
  write(*,*) int16Attribute( tab, "int1" ) ! output '3'
  write(*,*) int16Attribute( tab, "int2" ) ! output '4'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) int16Attribute( att ) ! output the sequence 1, 2
  end do

  call release(set)

end program example_int16attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16Data</TT><A NAME="func:f90:int16Data"></A><A NAME="6357"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function int16ArrayData( array ) 
<BR>
function int16ColumnData( column ) 
<BR>
function int16ColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT8), dimension(:), pointer 
<BR>
The data is returned as a flat vector regardless of the dimensionality of the
data.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned in a vector regardles of the dimensionality of the data. In particular, when accessing a scalar column cell, a vector of length 1 is returned, which contains the single scalar value.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_int16data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:,:,:,:), pointer :: c1, c2
  integer(kind=INT16), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int16Array4Data(col1)
  c2 =&gt; int16Array4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; int16Data( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_int16data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16VectorData</TT><A NAME="func:f90:int16VectorData"></A><A NAME="6360"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from an array or column cell containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int16ArrayVectorData( array ) 
<BR>
function int16ColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int16VectorData(col1,m)
    c2 =&gt; int16VectorData(col2,m)
    do i=0,2 
      c1(i) = n
      c2(i) = c1(i)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellvectordata
! This example shows how to use the int16Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The array is then initialised,
program example_arrayvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT16), dimension(:), pointer :: a1, a2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER16, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER16, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int16VectorData(arr1)
  a2 =&gt; int16VectorData(arr2)
  do i=0,2 
    a1(i) = n
    a2(i) = a1(i)
    n = n + 1
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int16VectorData</TT><A NAME="func:f90:int16VectorData"></A><A NAME="6363"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int16ColumnVectorData( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT16), dimension(:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second column has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT16), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 10, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER16, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int16VectorData(col1)
  c2 =&gt; int16VectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = n
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INT32
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate that integer32 data is being
used.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array2Data</TT><A NAME="func:f90:int32Array2Data"></A><A NAME="6366"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from an array or column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ArrayArray2Data( array ) 
<BR>
function int32ColumnArray2DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the int32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; int32Array2Data(col1,k)
    c2 =&gt; int32Array2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = n
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
! This example shows how to use the int32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT32), dimension(:,:), pointer :: a1, a2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int32Array2Data(arr1)
  a2 =&gt; int32Array2Data(arr2)
  do j=0,3
    do i=0,2 
      a1(i,j) = n
      a2(i,j) = a1(i,j)
      n = n + 1
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array2Data</TT><A NAME="func:f90:int32Array2Data"></A><A NAME="6369"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:,:), pointer 
<BR>
The 2-dimensional data is returned as a 3-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int32Array2Data(col1)
  c2 =&gt; int32Array2Data(col2)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = n
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array3Data</TT><A NAME="func:f90:int32Array3Data"></A><A NAME="6372"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from an array or column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ArrayArray3Data( array ) 
<BR>
function int32ColumnArray3DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; int32Array3Data(col1,l)
    c2 =&gt; int32Array3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = n
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr2)
  do k=0,4
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array3Data</TT><A NAME="func:f90:int32Array3Data"></A><A NAME="6375"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from a column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:,:,:), pointer 
<BR>
The 3-dimensional data is returned as a 4-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int32Array3Data(col1)
  c2 =&gt; int32Array3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = n
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array4Data</TT><A NAME="func:f90:int32Array4Data"></A><A NAME="6378"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int16 data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ColumnArray4Data( column ) 
<BR>
function int32ColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int32Array4Data(col1,m)
    c2 =&gt; int32Array4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = n
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Array4Data</TT><A NAME="func:f90:int32Array4Data"></A><A NAME="6381"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function int32ColumnArray4Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:,:,:,:,:), pointer 
<BR>
The 4-dimensional column data is returned as a 5-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int32Array4Data(col1)
  c2 =&gt; int32Array4Data(col1)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Attribute</TT><A NAME="func:f90:int32Attribute"></A><A NAME="6384"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as an int32.
</LI>
<LI>INTERFACE 
<BR>
function int32ArrayAttribute( array, name ) 
<BR>
function int32AttributableAttribute( attributable, name ) 
<BR>
function int32Attribute( attribute ) 
<BR>
function int32BlockAttribute( block, name ) 
<BR>
function int32ColumnAttribute( column, name ) 
<BR>
function int32DataSetAttribute( dataSet, name ) 
<BR>
function int32TableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of the attributable containing the required attribute.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of the block containing the required attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of the dataset containing the required attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the required attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of the table containing the required attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how int32 attributes are used.
! The program creates a dataset containing two int32 attributes,
! together with a table containing two int32 attributes.
! The attributes are then accessed, by name, with
! the int32Attribute() function.
! Also, it is shown how to access the attributes by position.
program example_int32attribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"int1",1,"int comment")
  call setAttribute(set,"int2",2,"int comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"int1",3,"int comment")
  call setAttribute(tab,"int2",4,"int comment")

  write(*,*) int32Attribute( set, "int1" ) ! output '1'
  write(*,*) int32Attribute( set, "int2" ) ! output '2'
  write(*,*) int32Attribute( tab, "int1" ) ! output '3'
  write(*,*) int32Attribute( tab, "int2" ) ! output '4'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) int32Attribute( att ) ! output the sequence 1, 2
  end do

  call release(set)

end program example_int32attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32Data</TT><A NAME="func:f90:int32Data"></A><A NAME="6387"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function int32ArrayData( array ) 
<BR>
function int32ColumnData( column ) 
<BR>
function int32ColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row 
<BR>
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:), pointer 
<BR>
The data is returned as a flat vector regardless of the dimensionality of the
data.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned in a vector regardles of the dimensionality of the data. In particular, when accessing a scalar column cell, a vector of length 1 is returned, which contains the single scalar value.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_int32data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:,:,:,:), pointer :: c1, c2
  integer(kind=INT32), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int32Array4Data(col1)
  c2 =&gt; int32Array4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; int32Data( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_int32data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32VectorData</TT><A NAME="func:f90:int32VectorData"></A><A NAME="6390"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from an array or column cell containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int32ArrayVectorData( array ) 
<BR>
function int32ColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer(kind=INT32), dimension(:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; int32VectorData(col1,m)
    c2 =&gt; int32VectorData(col2,m)
    do i=0,2 
      c1(i) = n
      c2(i) = c1(i)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellvectordata
! This example shows how to use the int32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The array is then initialised,
program example_arrayvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  integer(kind=INT32), dimension(:), pointer :: a1, a2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", INTEGER32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", INTEGER32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; int32VectorData(arr1)
  a2 =&gt; int32VectorData(arr2)
  do i=0,2 
    a1(i) = n
    a2(i) = a1(i)
    n = n + 1
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>int32VectorData</TT><A NAME="func:f90:int32VectorData"></A><A NAME="6393"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the int32 data from a column containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function int32ColumnVectorData( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>integer(kind=INT32), dimension(:,:), pointer
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second column has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=INT32), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 10, "table comment" )
  col1 = addColumn( tab, "column1", INTEGER32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; int32VectorData(col1)
  c2 =&gt; int32VectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = n
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INTEGER8
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate int8 data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INTEGER16
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate int16 data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
INTEGER32
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate int16 data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>intNullValue</TT><A NAME="func:f90:intNullValue"></A><A NAME="6396"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of the integer null value.
</LI>
<LI>INTERFACE 
<BR>
subroutine intNullValueArray( array ) 
<BR>
subroutine intNullValueColumn( column ) 
<BR>
subroutine intNullValueDataComponent( dataComponent ) 
<BR>
subroutine intNullValueNullable( nullable )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array whose null value is to be retrieved.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column whose null value is to be retrived.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
A handle of the dataComponent whose null value is to be retrieved.
</LI>
<LI>type(NullableT), intent(in) :: nullable 
<BR>
A handle of the nullable whose null value is to be retrieved.
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR>
Get the null value of an object containing integer data. It is an error to call
this function if the object's null value has not been defined. The logical
function nullDefined() may be used to determine if the null value of a geven
object has been defined.

<P>
The null value of an object containing integer data, may be defined with
a call to setNullValue().
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>isNotNull</TT><A NAME="func:f90:isNotNull"></A><A NAME="6423"></A>
</LI>
<LI>PURPOSE 
<BR>
NOT IMPLEMENTED
        Determine the state of all the values in an array or column.
</LI>
<LI>INTERFACE 
<BR>
function isNotNull( array ) 
<BR>
function isNotNull( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the values to be checked.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the values to be checked.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical, dimension(:), pointer :: isNotNullArray
A vector whose elements indicate the state of the corresponing values in the
given object.
If the vector element value is true, the corresponding value in the object is null.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>isNull</TT><A NAME="func:f90:isNull"></A><A NAME="6450"></A>
</LI>
<LI>PURPOSE 
<BR>
Determines if a value is null.
</LI>
<LI>INTERFACE 
<BR>
function isNullArray( array, position ) 
<BR>
function isNullCell( column, row, position ) 
<BR>
function isNullColumn( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the value to be checked.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the value to be checked.
</LI>
<LI>integer(kind=INT32), intent(in) :: position 
<BR>
The position of the value within the array (or the column cell in the case of a
multi-dimensional column) which is to be checked.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the value to be checked.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR>
True, if the value is null, false otherwise.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
In the case of integer values, an error will be raised if the object (array or column) does not have a
null-value defined.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>keepDataSet</TT><A NAME="func:f90:keepDataSet"></A><A NAME="6477"></A>
</LI>
<LI>PURPOSE 
<BR>
Tells the data set server object to not to discard the named data set.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: dataSetName 
<BR>
The name of the dataset.
</LI>
</UL>
</LI>
<LI>RETURNS  
<BR>
None 
</LI>
<LI>DESCRIPTION 
<BR>
The named data set will not be released from memory.

<P>
This subroutine must only be called by Meta Tasks.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the keepDataSet
! subroutine
program example_keepdiscarddataset

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet("test.dat",CREATE)
  call release(set)		  ! The dataset will be released from memory

  call keepDataSet("test.dat")	  ! Tell the dataset server not to discard
  				  ! the dataset with name "test.dat"

  set = dataSet("test.dat",READ)
  call release(set)		  ! The dataset will not be released from memory

  set = dataSet("test.dat",READ)  ! The dataset is already in memory, so this
  				  ! operation has virtually no overhead.

  call release(set)		  ! The dataset will not be released from memory
  call discardDataSet("test.dat") ! Tell the dataset server to discard and
  				  ! release the dataset with name "test.dat"

end program example_keepdiscarddataset
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:discardDataSet"><TT>discardDataSet</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>label</TT><A NAME="func:f90:label"></A><A NAME="6483"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the label (comment) of an object.
</LI>
<LI>INTERFACE 
<BR>
function arrayAttributeComment( array, name ) 
<BR>
function attributableAttributeComment( attributable, name ) 
<BR>
function blockAttributeComment( block, name ) 
<BR>
function columnAttributeComment( column, name ) 
<BR>
function dataSetAttributeComment( dataSet, name ) 
<BR>
function labelOfAttributable( attributable ) 
<BR>
function labelOfAttribute( attribute ) 
<BR>
function labelOfArray( array ) 
<BR>
function labelOfBlock( block ) 
<BR>
function labelOfColumn( column ) 
<BR>
function labelOfDataSet( dataSet ) 
<BR>
function labelOfLabelled( labelled ) 
<BR>
function labelOfTable( table ) 
<BR>
function tableAttributeComment( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT) :: array 
<BR>
A handle of an array.
</LI>
<LI>type(AttributableT) :: attributable 
<BR>
A handle of an attributable.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of an attribute.
</LI>
<LI>type(BlockT) :: block 
<BR>
A handle of a block.
</LI>
<LI>type(ColumnT) :: column 
<BR>
A handle of a column.
</LI>
<LI>type(DataSetT) :: dataSet 
<BR>
A handle of a dataset.
</LI>
<LI>type(LabelledT) :: labelled 
<BR>
A handle of a labelled.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the attribute from which the comment is to be retrieved.
</LI>
<LI>type(TableT) :: table 
<BR>
A handle of a table.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=IdentifierLength)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>labelled</TT><A NAME="func:f90:labelled"></A><A NAME="6486"></A>
</LI>
<LI>PURPOSE 
<BR></LI>
<LI>INTERFACE 
<BR>
function arrayLabelled( array ) 
<BR>
function attributableLabelled( attributable ) 
<BR>
function attributeLabelled( attribute ) 
<BR>
function blockLabelled( block ) 
<BR>
function columnLabelled( column ) 
<BR>
function datasetLabelled( dataSet ) 
<BR>
function tableLabelled( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of an array.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of an attributable.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of an attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of a block.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of a column.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of a dataSet.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of a table.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(LabelledT)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
LabelledT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare Labelled handle objects.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:label"><TT>label</TT></A>
        <A HREF="#func:f90:name"><TT>name</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
LOW_MEMORY
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate that the Low Memory Modelshould be used to open a dataset.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>mode</TT><A NAME="func:f90:mode"></A><A NAME="6495"></A>( dataSet )
</LI>
<LI>PURPOSE 
<BR>
Get the access mode of an object.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT) :: dataSet
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
The value returned is one of the enumeratioin values: READ, CREATE, MODIFY, TEMP
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the mode()
! function is used.
function addTableToSet( s, n, r )

  use dal
  
  implicit none

  type(DataSetT), intent(in) :: s
  character(len=*), intent(in) :: n
  integer, intent(in) :: r
  type(TableT) :: addTableToSet

  if( mode( s ).eq.READ ) then
    write(*,*) 'The table with name ', n, ' is read only'
  else
    addTableToSet = addTable(s,n,r)
  end if
end function addTableToSet

program example_mode

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(BlockT) blk
  integer i
  type(TableT) :: addTableToSet

  set = dataSet("test.dat",CREATE)
  tab = addTableToSet(set,"table1",10)
  call release( set )

  set = dataSet("test.dat",READ)
  tab = addTableToSet(set,"table2",10)
  call release( set )

end program example_mode
</PRE>
</LI>
<LI>SEE ALSO 
<BR>
READ
        CREATE
        MODIFY
        TEMP
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
MODIFY
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate that modify (Read and Write) mode should be used.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>name</TT><A NAME="func:f90:mode"></A><A NAME="6498"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the name of an object.
</LI>
<LI>INTERFACE 
<BR>
function nameOfArray( array ) 
<BR>
function nameOfAttributable( attributable ) 
<BR>
function nameOfAttribute( attribute ) 
<BR>
function nameOfBlock( block ) 
<BR>
function nameOfColumn( column ) 
<BR>
function nameOfDataSet( dataSet ) 
<BR>
function nameOfLabelled( labelled ) 
<BR>
function nameOfTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT) :: array 
<BR>
A handle of the array whose name is required.
</LI>
<LI>type(AttributableT) :: attributable 
<BR>
A handle of the attributable whose name is required.
</LI>
<LI>type(AttributeT) :: attribute 
<BR>
A handle of the attribute whose name is required.
</LI>
<LI>type(BlockT) :: block 
<BR>
A handle of the block whose name is required.
</LI>
<LI>type(ColumnT) :: column 
<BR>
A handle of the column whose name is required.
</LI>
<LI>type(DataSetT) :: dataSet 
<BR>
A handle of the dataset whose name is required.
</LI>
<LI>type(LabelledT) :: labelled 
<BR>
A handle of the labelled whose name is required.
</LI>
<LI>type(TableT) :: table 
<BR>
A handle of the table whose name is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=IdentifierLength) :: nameOfAttribute
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:label"><TT>label</TT></A>
        LabelledT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>next</TT><A NAME="func:f90:next"></A><A NAME="6504"></A>
</LI>
<LI>PURPOSE 
<BR>
Iterate to the next subtable.
</LI>
<LI>INTERFACE 
<BR>
function subTableNext( subTable )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(SubTableT), intent(in) :: subTable 
<BR>
A handle of the subTable.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
TBD
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>nullable</TT><A NAME="func:f90:nullable"></A><A NAME="6507"></A>
</LI>
<LI>PURPOSE 
<BR>
Convert a subclass of Nullable to Nullable.
</LI>
<LI>INTERFACE 
<BR>
function arrayNullable( array ) 
<BR>
function columnNullable( column ) 
<BR>
function dataComponentNullable( dataComponent )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
The handle of an array which is to be converted to a DataComponent 
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
The handle of a column which is to be converted to a DataComponent 
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
The handle of a dataComponent object which is to be converted to a
        Nullable object.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataComponentT) 
<BR>
The converted object is returned as a handle to a DataComponent object.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example illustrates the use of the dataComponent() function.
! The units of objects with data type BOOLEAN and STRING are meaningless
! and so are not displayed.
subroutine displayUnits( dcomponent )
  use dal
 
  implicit none

  type(DataComponentT) dcomponent
  integer dattype

  dattype = dataType( dcomponent )
  write(*,*) dattype
  if(dattype.eq.INTEGER8.or.dattype.eq.INTEGER16.or.dattype.eq.INTEGER32 &amp;
    .or.dattype.eq.REAL32.or.dattype.eq.REAL64) then
    write(*,*) units( dcomponent )
  end if

end subroutine displayUnits

program example_datacomponent

  use dal
  
  implicit none

  type(ArrayT) arr
  type(BlockT) blk
  type(ColumnT) col
  type(DataSetT) set
  type(TableT) tab
  integer i, j
  integer, dimension(3), parameter :: s = (/ 2,3,4 /)

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))
  arr = addArray(set, "array1", INTEGER16, dimensions=s, units="klm" )
  arr = addArray(set, "array2", INTEGER32, dimensions=s, units="kla" )

  do i = 0, numberOfBlocks( set ) - 1
    blk = block( set, i, READ )
    if( blockType( blk ).eq.ARRAY_BLOCK ) then
      arr = array( set, name( blk ), READ )
      call displayUnits( dataComponent( arr ) )
    else
      tab = table( set, name( blk ) )
      do j = 0, numberOfColumns( tab ) - 1
        col = column( tab, j, READ )
        call displayUnits( dataComponent( col ) )
      end do
    end if
  end do
  call release(set)

end program example_datacomponent
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>nullDefined</TT><A NAME="func:f90:nullDefined"></A><A NAME="6510"></A>
</LI>
<LI>PURPOSE 
<BR>
Determine if the integer null value has been set.
</LI>
<LI>INTERFACE 
<BR>
function nullDefinedArray( array ) 
<BR>
function nullDefinedColumn( column ) 
<BR>
function nullDefinedDataComponent( dataComponent ) 
<BR>
function nullDefinedNullable( nullable )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
A handle of the dataComponent.
</LI>
<LI>type(NullableT), intent(in) :: nullable 
<BR>
A handle of the nullable.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
This function is only relevant for objects containing boolean data.

<P>
For real objects, this function always returns true.

<P>
The null value of an object containing integer data may be defined by calling
setNullValue().
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>nullType</TT><A NAME="func:f90:nullType"></A><A NAME="6537"></A>
</LI>
<LI>PURPOSE 
<BR>
Gets the null value type of an object.
</LI>
<LI>INTERFACE 
<BR>
function nullTypeArray( array ) 
<BR>
function nullTypeColumn( column ) 
<BR>
function nullType( dataComponent ) 
<BR>
function nullTypeNullable( nullable )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
A handle of the dataComponent.
</LI>
<LI>type(NullableT), intent(in) :: nullable 
<BR>
A handle of the nullable.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
Returns one of: INTEGER_NULL, REAL_NULL, STRING_NULL, UNDEFINED_NULL
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
<P>
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfAttributes</TT><A NAME="func:f90:numberOfAttributes"></A><A NAME="6564"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the number of attributes in an object.
</LI>
<LI>INTERFACE 
<BR>
function numberOfAttributesOfArray( array ) 
<BR>
function numberOfAttributesOfAttrib( attributable ) 
<BR>
function numberOfAttributesOfBlock( block ) 
<BR>
function numberOfAttributesOfColumn( column) 
<BR>
function numberOfAttributesOfDataSet( dataSet ) 
<BR>
function numberOfAttributesOfTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type( ArrayT ), intent(in) :: array 
<BR>
A handle of the array for which the number of attributes is required.
</LI>
<LI>type( AttributableT ), intent(in) :: attributable 
<BR>
A handle of the attributable for which the number of attributes is required.
</LI>
<LI>type( BlockT ), intent(in) :: block 
<BR>
A handle of the block for which the number of attributes is required.
</LI>
<LI>type( ColumnT ), intent(in) :: column 
<BR>
A handle of the column for which the number of attributes is required.
</LI>
<LI>type( DataSetT ), intent(in) :: dataSet 
<BR>
A handle of the dataset for which the number of attributes is required.
</LI>
<LI>type( TableT ), intent(in) :: table 
<BR>
A handle of the table for which the number of attributes is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example show how the numberOfAttributes interface
! is used.
program example_numberofattributes
   
  use dal
  implicit none
 
  type(DataSetT) set
  type(TableT) tab
   
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.false.,"dataset bool comment")
   
  write(*,*) numberOfAttributes( set ) ! 2 attributes
  tab = addTable(set,"table",10);
  call addAttributes(attributable(tab),attributable(set))
  call setAttribute(tab,"sbool3",.false.,"dataset bool comment")
  write(*,*) numberOfAttributes( tab ) ! 3 attributes

  call release(set)
   
end program example_numberofattributes
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:setAttribute"><TT>setAttribute</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfBlocks</TT><A NAME="func:f90:numberOfBlocks"></A><A NAME="6570"></A>( dataSet )
</LI>
<LI>PURPOSE 
<BR>
Get the number of blocks in a dataset.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the numberOfBlocks interface
! is used.
program example_numberofblocks

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(BlockT) blk
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table1",10)
  tab = addTable(set,"table2",100)
  tab = addTable(set,"table3",1000)

  write(*,*) numberOfBlocks( set ) ! 3 blocks

  ! For each block, display the name, and
  ! add a comment.
  do i=0,numberOfBlocks( set ) - 1
    blk = block( set, i, MODIFY )
    write(*,*) name( blk )
    call addComment( blk, "A table comment" )
  end do

  call release(set)

end program example_numberofblocks
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfColumns</TT><A NAME="func:f90:numberOfColumns"></A><A NAME="6573"></A>( table )
</LI>
<LI>PURPOSE 
<BR>
Get the number of columns in a table.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type( TableT ), intent( in ) :: table
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This examples shows how the numberOfColumns()
! function is used.
program example_numberofcolumns

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))

  write(*,*) numberOfColumns( tab ) ! 7 columns

  ! For each column, display the name and
  ! add an attribute.
  do i=0, numberOfColumns( tab ) - 1
    col = column( tab, i, MODIFY )
    write(*,*) name( col )
    call setAttribute( col, "TLMAX", 10, "tlmax attribute" )
  end do

  call release(set)

end program example_numberofcolumns
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfDimensions</TT><A NAME="func:f90:numberOfDimensions"></A><A NAME="6576"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the number of dimensions of the data contained in an object.
</LI>
<LI>INTERFACE 
<BR>
function numberOfDimensionsOfArray( array ) 
<BR>
function numberOfDimensionsOfColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type( ArrayT ), intent(in) :: array 
<BR>
A handle of the array for which the number of dimensions is required.
</LI>
<LI>type( ColumnT ), intent(in) :: column 
<BR>
A handle of the column for which the number of dimensions is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
The number of the dimensions of the given object.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
For arrays the number of dimensions is between 1 and 3, and for columns
is between 1 and 4.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! two 3-dimensional arrays, and one table.
!
! It illustrates the use of the numberofdimensions interface.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
program example_numberofdimensions

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  integer :: i,j

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr = addArray(set, "array1", INTEGER32, dimensions=(/3/) )
  arr = addArray(set, "array2", dataType( arr ), dimensions=(/3,4/) )
  arr = addArray(set, "array3", dataType( arr ), dimensions=(/3,4,5/) )
  tab = addTable(set,"table",10)
  col = addColumn(tab,"col1",INTEGER8) ! scalar
  col = addColumn(tab,"col2",dataType(col),dimensions=(/3/)) ! vector
  col = addColumn(tab,"col3",dataType(col),dimensions=(/3,4/)) ! 2-dimensions
  col = addColumn(tab,"col4",dataType(col),dimensions=(/3,4,5/)) ! 3-dimensions
  col = addColumn(tab,"col5",dataType(col),dimensions=(/3,4,5,6/)) ! 4-dimensions

  do i = 0, numberOfBlocks( set ) - 1
    ! For each block which is an array, display the
    ! name and number of dimensions.
    if( blockType( set, i ).eq.ARRAY_BLOCK ) then
      arr = array( set, i, READ )
      write(*,*) name( arr ), numberOfDimensions( arr )
    else
      tab = table( set, i )
      do j = 0, numberOfColumns( tab ) - 1
        ! For each column, display the name
	! and the number of dimensions.
        col = column( tab, j, READ )
	write(*,*) name( col ), numberOfDimensions( col )
      end do
    end if
  end do

  call release(set)

end program example_numberofdimensions
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addArray"><TT>addArray</TT></A>
        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfElements</TT><A NAME="func:f90:numberOfElements"></A><A NAME="6585"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the number of data elements in an object.
</LI>
<LI>INTERFACE 
<BR>
function numberOfElementsOfColumn( column ) 
<BR>
A handle of the column for which the number of elements is required.
        function numberOfElementsOfArray( array )
A handle of the array for which the number of elements is required.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type( ArrayT ), intent(in) :: array 
<BR>
A handle of the array for which the number of elements is required.
</LI>
<LI>type( ColumnT ), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
For fixed-length columns the number of elements in each cell is returned. The
total number of elements in a column is therefore calculated by multiplying the
number of the rows in the column by the result of this function.
For variable-lenghth columns, zero is returned.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! two 3-dimensional arrays, and one table.
!
! It illustrates the use of the numberofelements interface.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
program example_numberofdimensions

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  integer :: i,j

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr = addArray(set, "array1", INTEGER32, dimensions=(/3/) )
  arr = addArray(set, "array2", dataType( arr ), dimensions=(/3,4/) )
  arr = addArray(set, "array3", dataType( arr ), dimensions=(/3,4,5/) )
  tab = addTable(set,"table",10)
  col = addColumn(tab,"col1",INTEGER8) ! scalar
  col = addColumn(tab,"col2",dataType(col),dimensions=(/3/)) ! vector
  col = addColumn(tab,"col3",dataType(col),dimensions=(/3,4/)) ! 2-dimensions
  col = addColumn(tab,"col4",dataType(col),dimensions=(/3,4,5/)) ! 3-dimensions
  col = addColumn(tab,"col5",dataType(col),dimensions=(/3,4,5,6/)) ! 4-dimensions

  do i = 0, numberOfBlocks( set ) - 1
    ! For each block which is an array, display the
    ! name, number of dimensions and the number of elements.
    if( blockType( set, i ).eq.ARRAY_BLOCK ) then
      arr = array( set, i, READ )
      write(*,*) name( arr ), numberOfDimensions( arr ), numberOfElements( arr )
    else
      tab = table( set, i )
      do j = 0, numberOfColumns( tab ) - 1
        ! For each column, display the name,
	! number of dimensions and total number of elements.
        col = column( tab, j, READ )
	write(*,*) name( col ), numberOfDimensions( col ), numberOfRows( col ) * numberOfElements( col )
      end do
    end if
  end do

  call release(set)

end program example_numberofdimensions
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addArray"><TT>addArray</TT></A>
        <A HREF="#func:f90:addColumn"><TT>addColumn</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>numberOfRows</TT><A NAME="func:f90:numberOfRows"></A><A NAME="6594"></A>( table )
</LI>
<LI>PURPOSE 
<BR>
Get the number of rows in a table.
</LI>
<LI>INTERFACE 
<BR>
function numberOfRowsInColumn( column ) 
<BR>
function numberOfRowsInTable( table ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type( ColumnT ), intent(in) :: column 
<BR>
A handle of the column for which the number of rows is required.
</LI>
<LI>type( TableT ), intent(in) :: table 
<BR>
A handle of the table for which the number of rows is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>integer 
<BR>
The number of rows.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the numberOfRows
! interface is used.
program example_numberofrows

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table1",10)
  tab = addTable(set,"table2",100)
  tab = addTable(set,"table3",1000)

  do i=0,numberOfBlocks( set ) - 1
    tab = table( set, i )
    write(*,*) name( tab ), numberOfRows( tab )
  end do

  call release(set)

end program example_numberofrows
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addTable"><TT>addTable</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>parent</TT><A NAME="func:f90:parent"></A><A NAME="6600"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the parent object of an object.
</LI>
<LI>INTERFACE 
<BR>
function parentAttributable( attribute ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(AttributableT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the parent interface
! is used.
subroutine test1( set, tab, arr, col )

  use dal

  type(DataSetT), intent(in) :: set
  type(TableT), intent(in) :: tab
  type(ArrayT), intent(in) :: arr
  type(ColumnT), intent(in) :: col
  type(AttributeT) att



  att = attribute( set,0 )
  write(*,*) name( parent( att ))
  if( name( parent( att )) /= name( set )) then
	call error('internalError',"problem in parent method" )
  end if

  att = attribute( tab,0 )
  write(*,*) name( parent( att ))
  if( name( parent( att )) /= name( tab )) then
	call error('internalError',"problem in parent method" )
  end if

  write(*,*) name( parent( tab ))
  if( name( parent( tab )) /= name( set )) then
	call error('internalError',"problem in parent method" )
  end if

  att = attribute( arr,0 )
  write(*,*) name( parent( att ))
  if( name( parent( att )) /= name( arr )) then
	call error('internalError',"problem in parent method" )
  end if

  write(*,*) name( parent( arr ))

  if( name( parent( arr )) /= name( set )) then
	call error('internalError',"problem in parent method" )
  end if

  att = attribute( col,0 )
  write(*,*) name( parent( att ))
  if( name( parent( att )) /= name( col )) then
	call error('internalError',"problem in parent method" )
  end if

  write(*,*) name( parent( col ))

  if( name( parent( col )) /= name( tab )) then
	call error('internalError',"problem in parent method" )
  end if

  write(*,*) name( parent( parent( col )))

  if( name( parent( parent( col ))) /= name( set )) then
	call error('internalError',"problem in parent method" )
  end if

end subroutine test1


program example_parent

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  type(ArrayT) arr
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sint8",1_int8,"int8 unit","set int8 comment")
  tab = addTable(set,"some table",100)
  call setAttribute(tab,"sint8",1_int8,"int8 unit","set int8 comment")
  arr = addArray(set, "some array", INTEGER32, dimensions=s )
  call setAttribute(arr,"sint8",1_int8,"int8 unit","set int8 comment")
  col = addColumn(tab,"bool",BOOLEAN)
  call setAttribute(col,"TLMIN",1_int8,"int8 unit","set int8 comment")

  call test1( set,tab,arr,col )

  call release(set)

  set = dataSet("test.dat",READ)
  tab = table(set,0)
  arr = array(set,1,READ)
  col = column(tab,0,READ)

  call test1( set,tab,arr,col )

  call release(set)

end program example_parent
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>parent</TT><A NAME="func:f90:parent"></A><A NAME="6603"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the parent object of an object.
</LI>
<LI>INTERFACE 
<BR>
function parentDataSetOfArray( array )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataSetT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See above.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>parent</TT><A NAME="func:f90:parent"></A><A NAME="6606"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the parent object of an object.
</LI>
<LI>INTERFACE 
<BR>
function parentDataSetOfBlock( block )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataSetT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See above.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>parent</TT><A NAME="func:f90:parent"></A><A NAME="6609"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the parent object of an object.
</LI>
<LI>INTERFACE 
<BR>
function parentDataSetOfTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(DataSetT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See above.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>parent</TT><A NAME="func:f90:parent"></A><A NAME="6612"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the parent object of an object.
</LI>
<LI>INTERFACE 
<BR>
function parentTable( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(TableT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
See above.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>qualifiedName</TT><A NAME="func:f90:qualifiedName"></A><A NAME="6615"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the fully qualified name of an object.
</LI>
<LI>INTERFACE 
<BR>
function qualifiedNameOfArray( array ) 
<BR>
function qualifiedNameOfAttributable( attributable ) 
<BR>
function qualifiedNameOfAttribute( attribute ) 
<BR>
function qualifiedNameOfBlock( block ) 
<BR>
function qualifiedNameOfColumn( column ) 
<BR>
function qualifiedNameOfDataSet( dataSet ) 
<BR>
function qualifiedNameOfLabelled( labelled ) 
<BR>
function qualifiedNameOfTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT) :: array 
<BR>
A handle of the array whose fully qualified name is required.
</LI>
<LI>type(AttributableT) :: attributable 
<BR>
A handle of the attributable whose fully qualified name is required.
</LI>
<LI>type(AttributeT) :: attribute 
<BR>
A handle of the attribute whose fully qualified name is required.
</LI>
<LI>type(BlockT) :: block 
<BR>
A handle of the block whose fully qualified name is required.
</LI>
<LI>type(ColumnT) :: column 
<BR>
A handle of the column whose fully qualified name is required.
</LI>
<LI>type(DataSetT) :: dataSet 
<BR>
A handle of the dataset whose fully qualified name is required.
</LI>
<LI>type(LabelledT) :: labelled 
<BR>
A handle of the labelled whose fully qualified name is required.
</LI>
<LI>type(TableT) :: table 
<BR>
A handle of the table whose fully qualified name is required.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=IdentifierLength)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the qualifiedName
! interface is used.
program example_qualifiedname

  use dal

  type(DataSetT) :: set
  type(ArrayT) :: arr
  type(TableT) :: tab
  type(ColumnT) :: col
  type(AttributeT) :: att

  set = dataSet("test.dat",create)
  call setAttribute(set,"sbool",.false.,"set bool comment")

  arr = addArray(set,"array",integer32, dimensions=(/ 1,2,3 /))
  call setAttribute(arr,"abool",.true.,"arr bool comment")

  tab = addTable(set,"table",10)
  call setAttribute(tab,"tbool",.false.,"tab bool comment")

  col = addColumn(tab,"column",INT32,units="UNITS",comment="Column")
  call setAttribute(col,"tlmin",1_int32,"int32 unit","col int32 comment")

  write(*,*) "qualified data set name: ", qualifiedName( set ) ! test.dat
  att = attribute( set, "sbool" )
  write(*,*) "qualified data set attribute name: ", qualifiedName( att ) !"test.dat:sbool
  write(*,*) "qualified table name: ", qualifiedName( tab )! test.dat:table
  att = attribute( tab, "tbool" )
  write(*,*) "qualified table attribute name: ", qualifiedName( att ) ! test.dat:table:tbool
  write(*,*) "qualified array name: ", qualifiedName( arr ) ! test.dat:array
  att = attribute( arr, "abool" )
  write(*,*) "qualified array attribute name: ", qualifiedName( att ) ! test.dat:array:abool
  write(*,*) "qualified column name: ", qualifiedName( col ) ! test.dat:table:column
  att = attribute( col, "tlmin" )
  write(*,*) "qualified array attribute name: ", qualifiedName( att ) ! test.dat:table:column:tlmin

  call release(set)

end program example_qualifiedname
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
READ
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate read access to an object.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
REAL32
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate an object contains data of type real32 (float).
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array2Data</TT><A NAME="func:f90:real32Array2Data"></A><A NAME="6618"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from an array or a column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ArrayArray2Data( array ) 
<BR>
function real32ColumnArray2DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the real32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; real32Array2Data(col1,k)
    c2 =&gt; real32Array2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = n
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
! This example shows how to use the real32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=SINGLE), dimension(:,:), pointer :: a1, a2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real32Array2Data(arr1)
  a2 =&gt; real32Array2Data(arr2)
  do j=0,3
    do i=0,2 
      a1(i,j) = n
      a2(i,j) = a1(i,j)
      n = n + 1
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array2Data</TT><A NAME="func:f90:real32Array2Data"></A><A NAME="6621"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:,:), pointer 
<BR>
The 2-dimensional column data is returned as a 3-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real32Array2Data(col1)
  c2 =&gt; real32Array2Data(col2)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = n
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array3Data</TT><A NAME="func:f90:real32Array3Data"></A><A NAME="6624"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from an an array or a column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ArrayArray3Data( array ) 
<BR>
function real32ColumnArray3DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
</LI>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>integer, intent(in) :: row
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; real32Array3Data(col1,l)
    c2 =&gt; real32Array3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = n
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=SINGLE), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real32Array3Data(arr1)
  a2 =&gt; real32Array3Data(arr2)
  do k=0,4
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array3Data</TT><A NAME="func:f90:real32Array3Data"></A><A NAME="6627"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from an column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:,:,:), pointer 
<BR>
The 3-dimensional column data is returned as a 4-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real32Array3Data(col1)
  c2 =&gt; real32Array3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = n
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array4Data</TT><A NAME="func:f90:real32Array4Data"></A><A NAME="6630"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; real32Array4Data(col1,m)
    c2 =&gt; real32Array4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = n
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Array4Data</TT><A NAME="func:f90:real32Array4Data"></A><A NAME="6633"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real32ColumnArray4Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:,:,:,:,:), pointer 
<BR>
The 4-dimensional data is returned as a 5-dimensional array.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real32Array4Data(col1)
  c2 =&gt; real32Array4Data(col1)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Attribute</TT><A NAME="func:f90:real32Attribute"></A><A NAME="6636"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as a real32.
</LI>
<LI>INTERFACE 
<BR>
function real32ArrayAttribute( array, name ) 
<BR>
function real32AttributableAttribute( attributable, name ) 
<BR>
function real32Attribute( attribute ) 
<BR>
function real32BlockAttribute( Block, name ) 
<BR>
function real32ColumnAttribute( column, name ) 
<BR>
function real32DataSetAttribute( dataSet, name ) 
<BR>
function real32TableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required attribute.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of the attributable containing the required attribute.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of the attribute.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of the block containing the required attribute.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required attribute.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A handle of the dataset containing the required attribute.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the required attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A handle of the table containing the required attribute.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how real32 attributes are used.
! The program creates a dataset containing two real32 attributes,
! together with a table containing two real32 attributes.
! The attributes are then accessed, by name, with
! the real32Attribute() function.
! Also, it is shown how to access the attributes by position.
program example_real32attribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"real1",1.0,"real comment")
  call setAttribute(set,"real2",2.0,"real comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"real1",3.0,"real comment")
  call setAttribute(tab,"real2",4.0,"real comment")

  write(*,*) real32Attribute( set, "real1" ) ! output '1.0'
  write(*,*) real32Attribute( set, "real2" ) ! output '2.0'
  write(*,*) real32Attribute( tab, "real1" ) ! output '3.0'
  write(*,*) real32Attribute( tab, "real2" ) ! output '4.0'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) real32Attribute( att ) ! output the sequence 1.0, 2.0
  end do

  call release(set)

end program example_real32attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32Data</TT><A NAME="func:f90:real32Data"></A><A NAME="6639"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function real32ArrayData( array ) 
<BR>
function real32ColumnData( column ) 
<BR>
function real32ColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column
A handle of the column containing the required data.
</LI>
<LI>integer, intent(in) :: row
The row number of the column cell containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:), pointer 
<BR>
The data is returned as a flat vector regardless of the dimensionality of the
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The data is returned in a vector regardles of the dimensionality of the data. In particular, when accessing a scalar column cell, a vector of length 1 is returned, which contains the single scalar value.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_real32data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:,:,:,:), pointer :: c1, c2
  real(kind=SINGLE), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real32Array4Data(col1)
  c2 =&gt; real32Array4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; real32Data( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_real32data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32VectorData</TT><A NAME="func:f90:real32VectorData"></A><A NAME="6642"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from an array or column cell containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function real32ArrayVectorData( array ) 
<BR>
function real32ColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the required data.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the data to be accessed.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=SINGLE), dimension(:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; real32VectorData(col1,m)
    c2 =&gt; real32VectorData(col2,m)
    do i=0,2 
      c1(i) = n
      c2(i) = c1(i)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellvectordata
! This example shows how to use the int32Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The array is then initialised,
program example_arrayvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=SINGLE), dimension(:), pointer :: a1, a2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL32, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL32, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real32VectorData(arr1)
  a2 =&gt; real32VectorData(arr2)
  do i=0,2 
    a1(i) = n
    a2(i) = a1(i)
    n = n + 1
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real32VectorData</TT><A NAME="func:f90:real32VectorData"></A><A NAME="6645"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real32 data from a column containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function real32ColumnVectorData( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the required data.
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>real(kind=SINGLE), dimension(:,:), pointer 
<BR></LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second column has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=SINGLE), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 10, "table comment" )
  col1 = addColumn( tab, "column1", REAL32, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real32VectorData(col1)
  c2 =&gt; real32VectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = n
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
REAL64
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate an object contains data of type real64 (double).
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array2Data</TT><A NAME="func:f90:real64Array2Data"></A><A NAME="6648"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from an array or column cell containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ArrayArray2Data( array ) result(ptr)
        function real64ColumnArray2DataElement( column, row ) result( ptr )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to use the real64Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do k=0,numberOfRows(tab) - 1
    c1 =&gt; real64Array2Data(col1,k)
    c2 =&gt; real64Array2Data(col2,k)
    do j=0,3
      do i=0,2 
        c1(i,j) = n
        c2(i,j) = c1(i,j)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray2data
! This example shows how to use the real64Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=DOUBLE), dimension(:,:), pointer :: a1, a2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL64, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL64, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real64Array2Data(arr1)
  a2 =&gt; real64Array2Data(arr2)
  do j=0,3
    do i=0,2 
      a1(i,j) = n
      a2(i,j) = a1(i,j)
      n = n + 1
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array2Data</TT><A NAME="func:f90:real64Array2Data"></A><A NAME="6651"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from a column containing 2-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ColumnArray2Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 2-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array2data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(2), parameter :: s = (/ 3,4 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real64Array2Data(col1)
  c2 =&gt; real64Array2Data(col2)

  n = 0
  do k=0,numberOfRows(tab) - 1
    do j=0,3
      do i=0,2 
        c1(i,j,k) = n
        c2(i,j,k) = c1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array2data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array3Data</TT><A NAME="func:f90:real64Array3Data"></A><A NAME="6654"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from an array or a column cell containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ArrayArray3Data( array ) 
<BR>
function real64ColumnArray3DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:,:), pointer
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do l=0,numberOfRows(tab) - 1
    c1 =&gt; real64Array3Data(col1,l)
    c2 =&gt; real64Array3Data(col2,l)
    do k=0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k) = n
          c2(i,j,k) = c1(i,j,k)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray3data
! This example shows how to use the int8Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_arrayarray3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=DOUBLE), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL64, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL64, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real64Array3Data(arr1)
  a2 =&gt; real64Array3Data(arr2)
  do k=0,4
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k)
        n = n + 1
      end do
    end do
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayarray3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array3Data</TT><A NAME="func:f90:real64Array3Data"></A><A NAME="6657"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from a column containing 3-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ColumnArray3Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 3-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array3data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(3), parameter :: s = (/ 3,4,5 /)
  integer :: i,j,k,l,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real64Array3Data(col1)
  c2 =&gt; real64Array3Data(col1)

  n = 0
  do l=0,numberOfRows(tab) - 1
    do k = 0,4
      do j=0,3
        do i=0,2 
          c1(i,j,k,l) = n
          c2(i,j,k,l) = c1(i,j,k,l)
          n = n + 1
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array3data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array4Data</TT><A NAME="func:f90:real64Array4Data"></A><A NAME="6660"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from a column cell containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ColumnArray4DataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellarray4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; real64Array4Data(col1,m)
    c2 =&gt; real64Array4Data(col2,m)
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l) = n
            c2(i,j,k,l) = c1(i,j,k,l)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellarray4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Array4Data</TT><A NAME="func:f90:real64Array4Data"></A><A NAME="6663"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from a column containing 4-dimensional array data.
</LI>
<LI>INTERFACE 
<BR>
function real64ColumnArray4Data( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:,:,:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_array4data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:,:,:), pointer :: c1, c2
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real64Array4Data(col1)
  c2 =&gt; real64Array4Data(col1)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_array4data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Attribute</TT><A NAME="func:f90:real64Attribute"></A><A NAME="6666"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as a real64.
</LI>
<LI>INTERFACE 
<BR>
function real64ArrayAttribute( array, name ) 
<BR>
function real64AttributableAttribute( attributable, name ) 
<BR>
function real64Attribute( attribute ) 
<BR>
function real64BlockAttribute( Block, name ) 
<BR>
function real64ColumnAttribute( column, name ) 
<BR>
function real64DataSetAttribute( dataSet, name ) 
<BR>
function real64TableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>character(len=*), intent(in) :: name 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how real64 attributes are used.
! The program creates a dataset containing two real64 attributes,
! together with a table containing two real64 attributes.
! The attributes are then accessed, by name, with
! the real64Attribute() function.
! Also, it is shown how to access the attributes by position.
program example_real64attribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"real1",1.0,"real comment")
  call setAttribute(set,"real2",2.0,"real comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"real1",3.0,"real comment")
  call setAttribute(tab,"real2",4.0,"real comment")

  write(*,*) real64Attribute( set, "real1" ) ! output '1.0'
  write(*,*) real64Attribute( set, "real2" ) ! output '2.0'
  write(*,*) real64Attribute( tab, "real1" ) ! output '3.0'
  write(*,*) real64Attribute( tab, "real2" ) ! output '4.0'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) real64Attribute( att ) ! output the sequence 1.0, 2.0
  end do

  call release(set)

end program example_real64attribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64Data</TT><A NAME="func:f90:real64Data"></A><A NAME="6669"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from an array, column or column cell.
</LI>
<LI>INTERFACE 
<BR>
function real64ArrayData( array ) 
<BR>
function real64ColumnData( column ) 
<BR>
function real64ColumnDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two 4-dimensional arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, and then the second column
! is output by accessing the column's data as a flat vector.
program example_real64data

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:,:,:,:), pointer :: c1, c2
  real(kind=DOUBLE), dimension(:), pointer :: cd
  integer, dimension(4), parameter :: s = (/ 3,4,5,6 /)
  integer :: i,j,k,l,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 5, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real64Array4Data(col1)
  c2 =&gt; real64Array4Data(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do l=0,5
      do k=0,4
        do j=0,3
          do i=0,2 
            c1(i,j,k,l,m) = n
            c2(i,j,k,l,m) = c1(i,j,k,l,m)
            n = n + 1
          end do
        end do
      end do
    end do
  end do

  call release(col1)
  call release(col2)

  ! Output the col2
  cd =&gt; real64Data( col2 ) ! Access the column's 4-dimensional data as a flat vector.

  do n = 0,numberOfElements(col1) * numberOfRows(tab) - 1
    write(*,*) cd(n)
  end do

  call release(col2)
  call release(set)

end program example_real64data
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64VectorData</TT><A NAME="func:f90:real64VectorData"></A><A NAME="6672"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from an array or column cell containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function real64ArrayVectorData( array ) 
<BR>
function real64ColumnVectorDataElement( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
</LI>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>integer, intent(in) :: row
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised, on a row-by-row
! basis (i.e. accessing the column's data cell-by-cell),
! before the dataset is released (closed).
program example_cellvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 100, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers

  n = 0
  do m=0,numberOfRows(tab) - 1
    c1 =&gt; real64VectorData(col1,m)
    c2 =&gt; real64VectorData(col2,m)
    do i=0,2 
      c1(i) = n
      c2(i) = c1(i)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_cellvectordata
! This example shows how to use the int64Array2Data interface.
! In the example a dataset is created (opened) containing
! a table with 2 vector arrays.
!
! The second array has the same data type as the first; this
! is ensured by using the arrayDataType() function to determine
! the data type of the first array.
!
! The array is then initialised,
program example_arrayvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ArrayT) arr1, arr2
  real(kind=DOUBLE), dimension(:), pointer :: a1, a2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray( set, "array1", REAL64, s, "km", "array comment" )
  arr2 = addArray( set, "array2", REAL64, s, "km", "array comment" )

  ! fill with unique numbers

  n = 0
  a1 =&gt; real64VectorData(arr1)
  a2 =&gt; real64VectorData(arr2)
  do i=0,2 
    a1(i) = n
    a2(i) = a1(i)
    n = n + 1
  end do

  call release(arr1)
  call release(arr2)
  call release(set)

end program example_arrayvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>real64VectorData</TT><A NAME="func:f90:real64VectorData"></A><A NAME="6675"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the real64 data from a column containing vector data.
</LI>
<LI>INTERFACE 
<BR>
function real64ColumnVectorData( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE), dimension(:,:), pointer 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! In this example add dataset is created (opened) containing
! a table with 2 columns of two vector arrays.
!
! The second column has the same data type as the first; this
! is ensured by using the columnDataType() function to determine
! the data type of the first array.
!
! The columns are then  initialised before the
! dataset is released (closed).
program example_columnvectordata

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col1, col2
  real(kind=DOUBLE), dimension(:,:), pointer :: c1, c2
  integer, dimension(1), parameter :: s = (/ 3 /)
  integer :: i,m,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  tab = addTable(set, "table", 10, "table comment" )
  col1 = addColumn( tab, "column1", REAL64, "km", s, "column comment" )
  col2 = addColumn( tab, "column2", columnDataType( col1 ), "km", s, "column comment" )

  ! fill with unique numbers
  c1 =&gt; real64VectorData(col1)
  c2 =&gt; real64VectorData(col2)

  n = 0
  do m=0,numberOfRows(tab) - 1
    do i=0,2 
      c1(i,m) = n
      c2(i,m) = c1(i,m)
      n = n + 1
    end do
  end do

  call release(col1)
  call release(col2)
  call release(set)

end program example_columnvectordata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>relabel</TT><A NAME="func:f90:relabel"></A><A NAME="6678"></A>
</LI>
<LI>PURPOSE 
<BR>
Relabel an object.
</LI>
<LI>INTERFACE 
<BR>
subroutine relabelArray( array, newLabel ) 
<BR>
subroutine relabelAttributable( attributable, newLabel ) 
<BR>
subroutine relabelAttribute( attribute, newLabel ) 
<BR>
subroutine relabelBlock( block, newLabel ) 
<BR>
subroutine relabelColumn( column, newLabel ) 
<BR>
subroutine relabelDataSet( dataSet, newLabel ) 
<BR>
subroutine relabelLabelled( labelled, newLabel ) 
<BR>
subroutine relabelTable( table, newLabel )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>type(LabelledT), intent(in) :: labelled 
<BR></LI>
<LI>character(len=*), intent(in) :: newLabel 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>release</TT><A NAME="func:f90:release"></A><A NAME="6681"></A>
</LI>
<LI>PURPOSE 
<BR>
Release an object.
</LI>
<LI>INTERFACE 
<BR>
subroutine releaseArray( array ) 
<BR>
subroutine releaseBlock( block ) 
<BR>
subroutine releaseColumn( column ) 
<BR>
subroutine releaseDataSet( dataSet ) 
<BR>
subroutine releaseTable( table )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR>
Most examples call the release functions.
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>rename</TT><A NAME="func:f90:rename"></A><A NAME="6684"></A>
</LI>
<LI>PURPOSE 
<BR>
Rename an object.
</LI>
<LI>INTERFACE 
<BR>
subroutine renameArray( array, newName ) 
<BR>
subroutine renameAttributable( attributable, newName ) 
<BR>
subroutine renameAttribute( attribute, newName ) 
<BR>
subroutine renameBlock( block, newName ) 
<BR>
subroutine renameColumn( column, newName ) 
<BR>
subroutine renameDataSet( dataSet, newName ) 
<BR>
subroutine renameLabelled( labelled, newName ) 
<BR>
subroutine renameTable( table, newName )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>type(LabelledT), intent(in) :: labelled 
<BR></LI>
<LI>character(len=*), intent(in) :: newName 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the label, relabel, name and rename interfaces are used.
subroutine displayLabelled( l )
  use dal

  implicit none

  type(LabelledT), intent(in) :: l

  write(*,*) "the object with name ", name( l ), " has label: ", label(l)

end subroutine displayLabelled

subroutine display( set )
  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  type(AttributeT) att

  att = attribute( set, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  arr = array( set, 0, READ )
  write(*,*) name(arr), label( arr )
  call displayLabelled( labelled( arr ) )

  att = attribute( arr, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  tab = table( set, 1 )
  write(*,*) name(tab), label( tab )
  call displayLabelled( labelled( tab ) )

  att = attribute( tab, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

  col = column( tab, 0, READ )
  write(*,*) name(col), label( col )
  call displayLabelled( labelled( col ) )

  att = attribute( col, 0 )
  write(*,*) name(att), label( att )
  call displayLabelled( labelled( att ) )

end subroutine display

program example_labelled

  use dal

  implicit none

  type(DataSetT) set
  type(ArrayT) arr
  type(TableT) tab
  type(ColumnT) col
  ! type(AttributeT) att
  ! integer(kind=int32), dimension(:,:,:), pointer :: a
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)

  ! create a set
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"att1","value1","a dataset attribute comment")
  arr = addArray(set, "array", INTEGER32, comment="an array comment", dimensions=s )
  call setAttribute(arr,"att2","value2","an array attribute comment")
  tab = addTable(set, "table", 10, comment="a table comment" )
  call setAttribute(tab,"att3","value3","a table attribute comment")
  col = addColumn(tab,"int8",INTEGER8,comment="a column comment")
  call setAttribute(col,"TLMAX","value4","a column attribute comment")
   
  call display( set )
  call relabel( tab, "a new table comment" )
  call rename( col, "newcolnm" )
  call display( set )

  call release( set )

end program example_labelled
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
RowT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare objects of type RowT.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>scale</TT><A NAME="func:f90:scale"></A><A NAME="6687"></A>
</LI>
<LI>PURPOSE 
<BR>
THIS INTERFACE IS NOT IMPLEMENTED.
        Get the scale factor of an object's data.
</LI>
<LI>INTERFACE 
<BR>
function scaleOfArray( array ) 
<BR>
function scaleOfColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR> 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>setAttribute</TT><A NAME="func:f90:setAttribute"></A><A NAME="6698"></A>
</LI>
<LI>PURPOSE 
<BR>
Create/Copy/Set an attribute.
</LI>
<LI>INTERFACE 
<BR>
subroutine arraySetAttribute( array, attribute ) 
<BR>
subroutine attributableSetAttribute( attributable, attribute ) 
<BR>
subroutine blockSetAttribute( block, attribute ) 
<BR>
subroutine columnSetAttribute( column, attribute ) 
<BR>
subroutine datasetSetAttribute( dataset, attribute ) 
<BR>
subroutine setBooleanArrayAttribute( array, name, booleanValue, comment
        ) 
<BR>
subroutine setBooleanAttributableAttribute( attributable, name,
        booleanValue, comment ) 
<BR>
subroutine setBooleanAttribute( attribute, booleanValue, comment ) 
<BR>
subroutine setBooleanBlockAttribute( block, name, booleanValue, comment
        ) 
<BR>
subroutine setBooleanColumnAttribute( column, name, booleanValue,
        comment ) 
<BR>
subroutine setBooleanDataSetAttribute( dataSet, name, booleanValue,
        comment ) 
<BR>
subroutine setBooleanTableAttribute( table, name, booleanValue, comment
        ) 
<BR>
subroutine setInt8ArrayAttribute( array, name, int8Value, units,
        comment ) 
<BR>
subroutine setInt8AttributableAttribute( attributable, name, int8Value,
        units, comment ) 
<BR>
subroutine setInt8Attribute( attribute, int8Value, units, comment ) 
<BR>
subroutine setInt8BlockAttribute( block, name, int8Value, units,
        comment ) 
<BR>
subroutine setInt8ColumnAttribute( column, name, int8Value, units,
        comment ) 
<BR>
subroutine setInt8DataSetAttribute( dataSet, name, int8Value, units, comment )
        subroutine setInt8TableAttribute( table, name, int8Value, units,
        comment ) 
<BR>
subroutine setInt16ArrayAttribute( array, name, int16Value, units,
        comment ) 
<BR>
subroutine setInt16AttributableAttribute( attributable, name, int16Value, units, comment )
        subroutine setInt16Attribute( attribute, int16Value, units, comment )
        
<BR>
subroutine setInt16BlockAttribute( block, name, int16Value, units,
        comment ) 
<BR>
subroutine setInt16ColumnAttribute( column, name, int16Value, units,
        comment ) 
<BR>
subroutine setInt16DataSetAttribute( dataSet, name, int16Value, units,
        comment ) 
<BR>
subroutine setInt16TableAttribute( table, name, int16Value, units,
        comment ) 
<BR>
subroutine setInt32ArrayAttribute( array, name, int32Value, units,
        comment ) 
<BR>
subroutine setInt32AttributableAttribute( attributable, name,
        int32Value, units, comment ) 
<BR>
subroutine setInt32Attribute( attribute, int32Value, units, comment )
        
<BR>
subroutine setInt32BlockAttribute( block, name, int32Value, units,
        comment ) 
<BR>
subroutine setInt32ColumnAttribute( column, name, int32Value, units,
        comment ) 
<BR>
subroutine setInt32DataSetAttribute( dataSet, name, int32Value, units,
        comment ) 
<BR>
subroutine setInt32TableAttribute( table, name, int32Value, units,
        comment ) 
<BR>
subroutine setReal32ArrayAttribute( array, name, real32Value, units,
        comment ) 
<BR>
subroutine setReal32AttributableAttribute( attributable, name,
        real32Value, units, comment ) 
<BR>
subroutine setReal32Attribute( attribute, real32Value, units, comment )
        
<BR>
subroutine setReal32BlockAttribute( block, name, real32Value, units,
        comment ) 
<BR>
subroutine setReal32ColumnAttribute( column, name, real32value, units,
        comment ) 
<BR>
subroutine setReal32DataSetAttribute( dataSet, name, real32Value,
        units, comment ) 
<BR>
subroutine setReal32TableAttribute( table, name, real32Value, units,
        comment ) 
<BR>
subroutine setReal64ArrayAttribute( array, name, real64Value, units,
        comment ) 
<BR>
subroutine setReal64AttributableAttribute( attributable, name,
        real64Value, units, comment ) 
<BR>
subroutine setReal64Attribute( attribute, real64Value, units, comment )
        
<BR>
subroutine setReal64BlockAttribute( block, name, real64Value, units,
        comment ) 
<BR>
subroutine setReal64ColumnAttribute( column, name, real64Value, units,
        comment ) 
<BR>
subroutine setReal64DataSetAttribute( dataSet, name, real64Value,
        units, comment ) 
<BR>
subroutine setReal64TableAttribute( table, name, real64Value, units,
        comment ) 
<BR>
subroutine setStringArrayAttribute( array, name, stringValue, comment )
        
<BR>
subroutine setStringAttributableAttribute( attributable, name,
        stringValue, comment ) 
<BR>
subroutine setStringAttribute( attribute, stringValue, comment ) 
<BR>
subroutine setStringBlockAttribute( block, name, stringValue, comment )
        
<BR>
subroutine setStringColumnAttribute( column, name, stringValue, comment
        ) 
<BR>
subroutine setStringDataSetAttribute( dataSet, name, stringValue,
        comment ) 
<BR>
subroutine setStringTableAttribute( table, name, stringValue, comment )
        
<BR>
subroutine tableSetAttribute( table, attribute ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>logical, intent(in) :: booleanValue 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>character(len=*), intent(in), optional :: comment 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataset 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
<LI>character(len=*), intent(in), optional :: units 
<BR></LI>
<LI>integer(kind=INT8), intent(in) :: int8Value 
<BR></LI>
<LI>integer(kind=INT16), intent(in) :: int16Value 
<BR></LI>
<LI>integer(kind=INT32), intent(in) :: int32Value 
<BR></LI>
<LI>real(kind=SINGLE), intent(in) :: real32Value 
<BR></LI>
<LI>real(kind=DOUBLE), intent(in) :: real64Value 
<BR></LI>
<LI>character(len=*), intent(in) :: stringValue 
<BR></LI>
</UL>
</LI>
<LI>RETURNS N/A
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the setAttribute
! interface is used.
program example_setattribute

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet("test.dat",CREATE)

  call setAttribute(set,"test1","some value","some comment to the attribute")
  call setAttribute(set,"TELESCOP","XMM","Telescope (mission) name")

  write(*,*) numberOfAttributes( set ) ! 2 attributes

  call release(set)

end program example_setattribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:attribute"><TT>attribute</TT></A>
        AttributeT
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 
 
</LI>
</UL> 

<P>
 
<UL>
<LI><B>NAME</B> 
<BR>        <TT>setAttributes</TT><A NAME="func:f90:setAttributes"></A><A NAME="6712"></A>( attributable, origin )
</LI>
<LI>PURPOSE 
<BR>
Replace the attributes in an attributable set with the attributes in a source set.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributableT), intent(in) :: origin 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR>
The attributes in source are copied to destination. Attributes, which have the same name are overwritten.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the setAttributes interface
! is used.
program example_setattributes
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
   
  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"sbool1",.false.,"dataset bool comment")
  call setAttribute(set,"sbool2",.false.,"dataset bool comment")
   
  tab = addTable(set,"table",10);
  call setAttributes(attributable(tab),attributable(set))

  write(*,*) numberOfAttributes( tab ) ! 2 attributes
  call release(set)
   
end program example_setattributes
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:addAttributes"><TT>addAttributes</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setData</TT><A NAME="func:f90:setData"></A><A NAME="6718"></A>
</LI>
<LI>PURPOSE 
<BR>
Set the data in a variable length column.
</LI>
<LI>INTERFACE 
<BR>
subroutine setBoolCell( column, row, booleanValues ) 
<BR>
subroutine setInt8Cell( column, row, int8Values ) 
<BR>
subroutine setInt16Cell( column, row, int16Values ) 
<BR>
subroutine setInt32Cell( column, row, int32Values ) 
<BR>
subroutine setReal32Cell( column, row, real32values ) 
<BR>
subroutine setReal64Cell( column, row, real64Values ) 
<BR>
subroutine setStringVariableCell( column, row, stringValues ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>logical(kind=BOOL), dimension(:), intent(in) :: booleanValues 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer(kind=INT8), dimension(:), intent(in) :: int8Values 
<BR></LI>
<LI>integer(kind=INT16), dimension(:), intent(in) :: int16Values 
<BR></LI>
<LI>integer(kind=INT32), dimension(:), intent(in) :: int32Values 
<BR></LI>
<LI>real(kind=SINGLE), dimension(:), intent(in) :: real32Values 
<BR></LI>
<LI>real(kind=DOUBLE), dimension(:), intent(in) :: real64Values 
<BR></LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR></LI>
<LI>character(len=*) :: stringValues 
<BR></LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how to set the data in
! a variable length column.
program example_setdata

  use dal

  implicit none

  integer, parameter :: nRows = 10
  integer, parameter :: maxCellSize = 100
  integer, dimension(0) :: zeroSize
  integer(kind=INT32) :: i
  type(DataSetT) :: set
  type(TableT) :: tab
  type(ColumnT) :: i8col1, i8col2, i16col1, i16col2, i32col1, i32col2
  type(ColumnT) :: r32col1, r32col2, r64col1, r64col2
  type(ColumnT) :: scol1, scol2, bcol1, bcol2

  logical(kind=bool), dimension(maxCellSize) :: b
  integer(kind=INT8), dimension(maxCellSize) :: i8
  integer(kind=INT16), dimension(maxCellSize) :: i16
  integer(kind=INT32), dimension(maxCellSize) :: i32
  real(kind=SINGLE), dimension(maxCellSize) :: r32
  real(kind=DOUBLE), dimension(maxCellSize) :: r64
  character(len=maxCellSize) :: s

  real(kind=SINGLE), dimension(:), pointer :: r32Data

  s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  do i = 1, maxCellSize
    i8(i) = i
    i16(i) = i
    i32(i) = i
    r32(i) = i
    r64(i) = i
    b(i) = ((i / 2).eq.0 )
  end do

  set = dataSet("test.dat",Create)
  tab = addTable(set,"someTable",nRows)

  bcol1 = addColumn(tab,"bcol1",Boolean, &amp;
	dimensions=zeroSize,comment="bool data")

  bcol2 = addColumn(tab,"bcol2",Boolean, &amp;
	dimensions=zeroSize,comment="bool data")

  i8col1 = addColumn(tab,"i8col1",Integer8,units="m", &amp;
	dimensions=zeroSize,comment="int8 data")

  i8col2 = addColumn(tab,"i8col2",Integer8,units="m", &amp;
	dimensions=zeroSize,comment="int8 data")

  i16col1 = addColumn(tab,"i16col1",Integer16,units="m", &amp;
	dimensions=zeroSize,comment="int16 data")

  i16col2 = addColumn(tab,"i16col2",Integer16,units="m", &amp;
	dimensions=zeroSize,comment="int16 data")

  i32col1 = addColumn(tab,"i32col1",Integer32,units="m", &amp;
	dimensions=zeroSize,comment="int32 data")

  i32col2 = addColumn(tab,"i32col2",Integer32,units="m", &amp;
	dimensions=zeroSize,comment="int32 data")

  r32col1 = addColumn(tab,"r32col1",Real32,units="m", &amp;
	dimensions=zeroSize,comment="real32 data")

  r32col2 = addColumn(tab,"r32col2",Real32,units="m", &amp;
	dimensions=zeroSize,comment="real32 data")

  r64col1 = addColumn(tab,"r64col1",Real64,units="m", &amp;
	dimensions=zeroSize,comment="real64 data")

  r64col2 = addColumn(tab,"r64col2",Real64,units="m", &amp;
	dimensions=zeroSize,comment="real64 data")

  scol1 = addColumn(tab,"scol1",String,units="m", &amp;
	dimensions=zeroSize,comment="string data")

  scol2 = addColumn(tab,"scol2",String, &amp;
	dimensions=zeroSize,comment="string data")

  do i=0,nRows - 1
  	call setData( bcol1, i, b( 1 : i + 1 ))
  	call setData( bcol2, i, b( 1 : nRows - i ))
  	call setData( i8col1, i, i8( 1 : i + 1 ))
  	call setData( i8col2, i, i8( 1 : nRows - i ))
  	call setData( i16col1, i, i16( 1 : i + 1 ))
  	call setData( i16col2, i, i16( 1 : nRows - i ))
  	call setData( i32col1, i, i32( 1 : i + 1 ))
  	call setData( i32col2, i, i32( 1 : nRows - i ))
  	call setData( r32col1, i, r32( 1 : i + 1 ))
  	call setData( r32col2, i, r32( 1 : nRows - i ))
  	call setData( r64col1, i, r64( 1 : i + 1 ))
  	call setData( r64col2, i, r64( 1 : nRows - i ))
  	call setData( scol1, i, s( 1 : i + 1 ))
  	call setData( scol2, i, s( 1 : nRows - i ))
  end do

  call release( set )

  set = dataSet("test.dat",Modify)
  tab = table(set,"someTable")

  bcol1 = column(tab,"bcol1",Read)
  bcol2 = column(tab,"bcol2",Read)
  i8col1 = column(tab,"i8col1",Read)
  i8col2 = column(tab,"i8col2",Read)
  i16col1 = column(tab,"i16col1",Read)
  i16col2 = column(tab,"i16col2",Read)
  i32col1 = column(tab,"i32col1",Read)
  i32col2 = column(tab,"i32col2",Read)
  r32col1 = column(tab,"r32col1",Read)
  r32col2 = column(tab,"r32col2",Read)
  r64col1 = column(tab,"r64col1",Read)
  r64col2 = column(tab,"r64col2",Read)
  scol1 = column(tab,"scol1",Read)
  scol2 = column(tab,"scol2",Read)

  do i = 0, nRows - 1
    write(*,*) boolData( bcol1, i )
    write(*,*) boolData( bcol2, i )
    write(*,*) int8Data( i8col1, i )
    write(*,*) int8Data( i8col2, i )
    write(*,*) int16Data( i16col1, i )
    write(*,*) int16Data( i16col2, i )
    write(*,*) int32Data( i32col1, i )
    write(*,*) int32Data( i32col2, i )
    write(*,*) real32Data( r32col1, i )
    write(*,*) real32Data( r32col2, i )
    write(*,*) real64Data( r64col1, i )
    write(*,*) real64Data( r64col2, i )
    write(*,*) stringCell( scol1, i )
    write(*,*) stringCell( scol2, i )
  end do

  call release( set )

end program example_setdata
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setExists</TT><A NAME="func:f90:setExists"></A><A NAME="6721"></A>( setName )
</LI>
<LI>PURPOSE 
<BR>
Determine if a dataset exists.
</LI>
<LI>ARGUMENTS

<UL>
<LI>character(len=*), intent(in) :: setName 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>logical 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the setexists()
! function is used.
program example_setexists

  use dal
  
  implicit none

  type(DataSetT) set

  set = dataSet("test.dat",CREATE)
  call release(set)

  if( setExists( "test.dat" ) ) then
    write(*,*) 'Very strange'
  end if
end program example_setexists
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setNullValue</TT><A NAME="func:f90:setNullValue"></A><A NAME="6724"></A>
</LI>
<LI>PURPOSE 
<BR>
Set the value of the integer null value.
</LI>
<LI>INTERFACE 
<BR>
subroutine setNullValue( array, value ) 
<BR>
subroutine setNullValue( column, value ) 
<BR>
subroutine setNullValue( dataComponent, value ) 
<BR>
subroutine setNullValue( nullable, value )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array whose null value is to be set.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column whose null value is to be set.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
A handle of the dataComponent whose null value is to be set.
</LI>
<LI>type(NullableT), intent(in) :: nullable 
<BR>
A handle of the nullable whose null value is to be set.
</LI>
<LI>integer(kind=INT32), intent(in) :: value 
<BR>
The value of the null value.
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR>
This function is only relevant for objects containing integer data, and should
not be called for objects containing other data types.

<P>
The null value of an object containing integer data (if it has been defined) may be obtained with the
function intNullValue().

<P>
The logical function nullDefined() may be used to determine if the null value
has been defined.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setToNull"><TT>setToNull</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setScaling</TT><A NAME="func:f90:setScaling"></A><A NAME="6751"></A>
</LI>
<LI>PURPOSE 
<BR>
NOT IMPLEMENTED.
        Set the scaling parameters to be applied to an object's data.
</LI>
<LI>INTERFACE 
<BR>
subroutine setScalingOfArray( array, zero, scale, toType ) 
<BR>
subroutine setScalingOfColumn( column, zero, scale, toType )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
</LI>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>real(kind=DOUBLE), intent(in) :: scale
</LI>
<LI>integer, intent(in) :: toType
</LI>
<LI>real(kind=DOUBLE), intent(in) :: zero
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setStringCell</TT><A NAME="func:f90:setStringCell"></A><A NAME="6754"></A>( column, row, value )
</LI>
<LI>PURPOSE 
<BR>
Set a cell in a string column.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle to the column which contains the cell to be set.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
Set row number of the cell to be set.
</LI>
<LI>character(len=*) :: value 
<BR>
This value will be copied into the specified cell.
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the setStringCell()
! function is used.
program example_setstringcell

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  character(len=12) :: s
  integer i

  s = "abcdef"

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))
  do i=0,numberOfRows(tab)-1
    write(s,'(A6,I2)') "string",i
    call setStringCell(col,i,s)
    write(*,*) stringCell( col, i )
  end do

  call release(set)

end program example_setstringcell
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setToNull</TT><A NAME="func:f90:setToNull"></A><A NAME="6757"></A>
</LI>
<LI>PURPOSE 
<BR>
Set a value to null.
</LI>
<LI>INTERFACE 
<BR>
subroutine setToNullArray( array, position ) 
<BR>
subroutine setToNullCell( column, row, position ) 
<BR>
subroutine setToNullColumn( column, row )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of the array containing the value to be set.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of the column containing the value to be set.
</LI>
<LI>integer(kind=INT32), intent(in) :: position 
<BR>
The position of the value within the array (or the column cell in the case of a
multi-dimensional column) which is to be set.
</LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR>
The row number of the column cell containing the value to be set.
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR>
In the case of integer values, an error will be raised if the object's null
value has not been defined.
The null value of an object containing integer data may be set with a call to
setNullValue(). The logical function nullDefined() determines if the null value
of an object has been defined.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how null values are used.
subroutine check( thisNullable )
  use dal
  type(NullableT), intent(in) :: thisNullable

  write(*,*) "Null defined?: ", nullDefined( thisNullable ), nullType( thisNullable )

end subroutine check

program example_nullvalues

  use dal
  use errorhandling

  implicit none

  type(DataSetT) set
  type(ArrayT) arr1, arr2
  type(TableT) tab
  type(ColumnT) col1, col2
  integer(kind=int32), dimension(:), pointer :: i32
  real(kind=double), dimension(:), pointer :: r64
  integer(kind=int32), dimension(:,:,:), pointer :: a1, a2
  integer, dimension(3), parameter :: s = (/ 3,4,2 /)
  integer :: i,j,k,n

  ! create a set
  set = dataSet("test.dat",CREATE)
  arr1 = addArray(set, "array1", INTEGER32, dimensions=s )
  arr2 = addArray(set, "array2", arrayDataType( arr1 ), dimensions=s )

  ! fill with unique numbers
  a1 =&gt; int32Array3Data(arr1)
  a2 =&gt; int32Array3Data(arr1)

  n = 0
  do k=0,1
    do j=0,3
      do i=0,2 
        a1(i,j,k) = n
        a2(i,j,k) = a1(i,j,k) + 1
        n = n + 1
      end do
    end do
  end do

  call setNullValue( arr1, 999999 )
  call check( nullable( arr1 ) )

  call setToNull( arr1, 0 )	! Set the first element of array arr1 to null.
      				! Would have given an error, if the null
      				! value of array arr1 had not been set. 

  if( nullType( arr1 ) .eq. INTEGER_NULL ) then ! 
    write(*,*) "Using null value of arr1, in arr2"
    call setNullValue( arr2, intNullValue( arr1 ))
  else
    call setNullValue( arr2, 999999 )
  end if

  call check( nullable( arr2 ) )

  call setToNull( arr2, 1 )	! Set the second element of array arr2 to null.
				! Would have given an error, if the null
				! value of array arr2 had not been set. 

  call release(arr1)
  call release(arr2)

  tab = addTable(set,"some table",100)

  col1 = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")

  i32 =&gt; int32Data(col1)
  do i=0,numberOfRows(tab)-1
    i32(i) = 3*i
  end do
  call setNullValue( col1, 999999 )
  call check( nullable( col1 ) )

  call setToNull( col1, 0 )	! Set the first element of column col1 to null.


  col2 = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  r64 =&gt; real64Data(col2)
  do i=0,numberOfRows(tab)-1
    r64(i) = 0.25*i
  end do

  ! col is a non-integer column and it would be an
  ! an error to call setNullValue().
  call check( nullable( col2 ) )

  call setToNull( col2, 0 )	! Set the first element of column col2 to null.

  if( hasNulls( col2 ) ) then
    do i=0,numberOfRows(tab)-1
      if( isNull( col2, i ) ) then
        write(*,*) "element", i, "is null"
      else
        write(*,*) "element", i, "is", r64(i)
      endif
    end do
  endif

  call release(col1)
  call release(col2)
  call release(set)

end program example_nullvalues
</PRE>
</LI>
<LI>SEE ALSO 
<BR>        <A HREF="#func:f90:hasNulls"><TT>hasNulls</TT></A>
        <A HREF="#func:f90:intNullValue"><TT>intNullValue</TT></A>
        <A HREF="#func:f90:isNotNull"><TT>isNotNull</TT></A>
        <A HREF="#func:f90:isNull"><TT>isNull</TT></A>
        <A HREF="#func:f90:nullable"><TT>nullable</TT></A>
        <A HREF="#func:f90:nullDefined"><TT>nullDefined</TT></A>
        <A HREF="#func:f90:nullType"><TT>nullType</TT></A>
        <A HREF="#func:f90:setNullValue"><TT>setNullValue</TT></A>
</LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>setUnits</TT><A NAME="func:f90:setUnits"></A><A NAME="6784"></A>
</LI>
<LI>PURPOSE 
<BR>
Set the units of an attribute, array or column.
</LI>
<LI>INTERFACE 
<BR>
subroutine setArrayAttributeUnits( array, attributeName, units ) 
<BR>
subroutine setArrayUnits( array, units ) 
<BR>
subroutine setAttributableAttributeUnits( attributable, attributeName, units ) 
<BR>
subroutine setAttributeUnits( attribute, units ) 
<BR>
subroutine setBlockAttributeUnits( block, attributeName, units ) 
<BR>
subroutine setColumnAttributeUnits( column, attributeName, units ) 
<BR>
subroutine setColumnUnits( column, units ) 
<BR>
subroutine setDataSetAttributeUnits( dataSet, attributeName, units ) 
<BR>
subroutine setTableAttributeUnits( table, attributeName, units )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array
</LI>
<LI>type(AttributableT), intent(in) :: attributable
</LI>
<LI>character(len=*), intent(in) :: attributeName
</LI>
<LI>type(AttributeT), intent(in) :: attribute
</LI>
<LI>type(BlockT), intent(in) :: block
</LI>
<LI>type(ColumnT), intent(in) :: column
</LI>
<LI>type(DataSetT), intent(in) :: dataSet
</LI>
<LI>type(TableT), intent(in) :: table
</LI>
<LI>character(len=*), intent(in) :: units
</LI>
</UL>
</LI>
<LI>RETURNS
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the setUnits interface
! is used.
program example_setunits

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")

  call release(set)

  set = dataSet("test.dat",MODIFY)
  tab = table( set, 0 )
  col = column( tab, 0, MODIFY )

  write(*,*) units( col )
  call setUnits( col, "mm" )
  write(*,*) units( col )

  call release(set)

end program example_setunits
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
SINGLE
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate single precision (real32) data.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
STRING
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate data of type character string.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>stringAttribute</TT><A NAME="func:f90:stringAttribute"></A><A NAME="6787"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the value of an attribute as a character string.
</LI>
<LI>INTERFACE 
<BR>
function stringArrayAttribute( array, name ) 
<BR>
function stringAttribute( attribute ) 
<BR>
function stringAttributableAttribute( attributable, name ) 
<BR>
function stringBlockAttribute( Block, name ) 
<BR>
function stringColumnAttribute( column, name ) 
<BR>
function stringDataSetAttribute( dataSet, name ) 
<BR>
function stringTableAttribute( table, name )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR></LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR></LI>
<LI>type(BlockT), intent(in) :: block 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>character(len=*), intent(in) :: name 
<BR></LI>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=stringAttributeLength) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how string attributes are used.
! The program creates a dataset containing two string attributes,
! together with a table containing two string attributes.
! The attributes are then accessed, by name, with
! the stringAttribute() function.
! Also, it is shown how to access the attributes by position.
program example_stringattribute
   
  use dal
  use errorhandling
  implicit none
   
  type(DataSetT) set
  type(TableT) tab
  type(AttributeT) att
  integer i

  set = dataSet("test.dat",CREATE)
  call setAttribute(set,"string1","abcdef","string comment")
  call setAttribute(set,"string2","ghijkl","string comment")
   
  tab = addTable(set,"table",10);
  call setAttribute(tab,"string1","abcdef","string comment")
  call setAttribute(tab,"string2","ghijkl","string comment")

  write(*,*) stringAttribute( set, "string1" ) ! output 'abcdef
  write(*,*) stringAttribute( set, "string2" ) ! output 'ghijkl'
  write(*,*) stringAttribute( tab, "string1" ) ! output 'abcdef
  write(*,*) stringAttribute( tab, "string2" ) ! output 'ghijkl'

  do i = 0, numberOfAttributes( set ) - 1
  	att = attribute( set, i )
	write(*,*) stringAttribute( att ) ! output the sequence 'abcdef', 'ghijkl'
  end do

  call release(set)
   
end program example_stringattribute
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>stringCell</TT><A NAME="func:f90:stringCell"></A><A NAME="6790"></A>( column, row )
</LI>
<LI>PURPOSE 
<BR>
Get the character string data from a column cell.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer(kind=INT32), intent(in) :: row 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=columnStringCellLength)
</LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the stringCell()
! function is used.
program example_stringcell

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  character(len=12) :: s
  integer i

  s = "abcdef"

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/12/))
  do i=0,numberOfRows(tab)-1
    write(s,'(A6,I2)') "string",i
    call setStringCell(col,i,s)
    write(*,*) stringCell( col, i )
  end do

  call release(set)

end program example_stringcell
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>subTable</TT><A NAME="func:f90:subTable"></A><A NAME="6793"></A>( table, from, to )
</LI>
<LI>PURPOSE 
<BR>
Get a subtable from a table.
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(TableT), intent(in) :: table 
<BR></LI>
<LI>integer, intent(in), optional :: from 
<BR></LI>
<LI>integer, intent(in), optional :: to 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(SubTableT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>
SubTableT
</LI>
<LI>PURPOSE 
<BR>
A derived type used to declare SubTable handles.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
TABLE_BLOCK
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate a table.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>table</TT><A NAME="func:f90:table"></A><A NAME="6796"></A>
</LI>
<LI>PURPOSE 
<BR>
Get a table from a dataset.
</LI>
<LI>INTERFACE 
<BR>
function tableWithName( dataSet, tableName ) 
<BR>
function tableWithNumber( dataSet, tableNumber )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR></LI>
<LI>character(len=*), intent(in) :: tableName 
<BR></LI>
<LI>integer, intent(in) :: tableNumber 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>type(TableT) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR>
The table may be specified either by number (the first block in a dataset has position zero) or by name.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
! This example shows how the table
! interface is used.
program example_table

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  integer i

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"table1",10)
  tab = addTable(set,"table2",100)
  tab = addTable(set,"table3",1000)

  do i=0,numberOfBlocks( set ) - 1
    tab = table( set, i ) ! Access table by number
    write(*,*) name( tab )
  end do

  tab = table( set, "table1" ) ! Access table by name
  write(*,*) name( tab )

  call release(set)

end program example_table
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
TableT
</LI>
<LI>PURPOSE 
<BR>
A derived type which is used to declare Table handles.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
TEMP
</LI>
<LI>PURPOSE 
<BR>
An enumeration value which is used to indicate temporary access to an object.
</LI>
<LI>DESCRIPTION 
<BR>
All changes made to an object, which has TEMP access, will be discarded, when the object is released.
</LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>units</TT><A NAME="func:f90:units"></A><A NAME="6799"></A>
</LI>
<LI>PURPOSE 
<BR>
Get the units of an object.
</LI>
<LI>INTERFACE 
<BR>
function arrayAttributeUnits( array, name ) 
<BR>
function arrayUnits( array ) 
<BR>
function attributableAttributeUnits( attributable, name ) 
<BR>
function blockAttributeUnits( block, name ) 
<BR>
function columnAttributeUnits( column, name ) 
<BR>
function columnUnits( column )
        function dataComponentUnits( dataComponent ) 
<BR>
function dataSetAttributeUnits( dataSet, name ) 
<BR>
function tableAttributeUnits( table, name )
        function unitsOfAttribute( attribute ) 
<BR></LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR>
A handle of an array from which to get an attribute's units.
</LI>
<LI>type(AttributableT), intent(in) :: attributable 
<BR>
A handle of an attributable from which to get an attribute's units.
</LI>
<LI>type(AttributeT), intent(in) :: attribute 
<BR>
A handle of an attribute from which to get the units.
</LI>
<LI>type(BlockT), intent(in) :: block 
<BR>
A handle of a block from which to get an attribute's units.
</LI>
<LI>type(ColumnT), intent(in) :: column 
<BR>
A handle of a column from which to get an attribute's units.
</LI>
<LI>type(DataComponentT), intent(in) :: dataComponent 
<BR>
A handle of a dataComponent.
</LI>
<LI>type(DataSetT), intent(in) :: dataSet 
<BR>
A dataset handle from which to get an attribute's units.
</LI>
<LI>character(len=*), intent(in) :: name 
<BR>
The name of the attribute.
</LI>
<LI>type(TableT), intent(in) :: table 
<BR>
A table handle from which to get an attribute's units.
</LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>character(len=IdentifierLength) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR><PRE>
program example_columnunits

  use dal
  
  implicit none

  type(DataSetT) set
  type(TableT) tab
  type(ColumnT) col
  integer i, coltype

  set = dataSet("test.dat",CREATE)
  tab = addTable(set,"some table",100)

  col = addColumn(tab,"bool",BOOLEAN)
  col = addColumn(tab,"int8",INTEGER8,units="cm",comment="int8 column")
  col = addColumn(tab,"int16",INTEGER16,units="dm",comment="int16 column")
  col = addColumn(tab,"int32",INTEGER32,units="m",comment="in32 column")
  col = addColumn(tab,"real32",REAL32,units="Dm",comment="real32 column")
  col = addColumn(tab,"real64",REAL64,units="hm",comment="real64 column")
  col = addColumn(tab,"string",STRING,comment="string column",dimensions=(/80/))

  do i=0, numberOfColumns( tab ) - 1
	    col = column( tab, i, READ )
    coltype = columnDataType( col )
    if(coltype.eq.INTEGER8.or.coltype.eq.INTEGER16.or.coltype.eq.INTEGER32 &amp;
    .or.coltype.eq.REAL32.or.coltype.eq.REAL64) then
      write(*,*) units( col )
    end if
  end do

  call release(set)

end program example_columnunits
</PRE>
</LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>unsetScaling</TT><A NAME="func:f90:unsetScaling"></A><A NAME="6802"></A>
</LI>
<LI>PURPOSE 
<BR>
NOT IMPLEMENTED.
        Remove the scaling factors from an object.
</LI>
<LI>INTERFACE 
<BR>
subroutine unsetScalingOfArray( array, toType ) 
<BR>
subroutine unsetScalingOfColumn( column, toType )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
<LI>integer, intent(in) :: toType 
<BR></LI>
</UL>
</LI>
<LI>RETURNS 
<BR>
None
</LI>
<LI>DESCRIPTION 
<BR>
toType specifies the data type which the object should have after the (un)scaling has been performed.
</LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<P>
</LI>
<LI><B>NAME</B> 
<BR>
USE_ENVIRONMENT
</LI>
<LI>PURPOSE 
<BR>
An enueration value which is used to indicates that the users environment should be used to establish which option ahould be taken. 
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>
WRITE
</LI>
<LI>PURPOSE 
<BR>
An enumeration which is used to indicate that an object should be accessed with read and modify permissions.
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR>
<BR>
None known. 

<P>
</LI>
<LI><B>NAME</B> 
<BR>        <TT>zero</TT><A NAME="func:f90:zero"></A><A NAME="6805"></A>
</LI>
<LI>PURPOSE 
<BR>
NOT IMPLEMENTED.
        Get the scaling origin from an object.
</LI>
<LI>INTERFACE 
<BR>
function zeroOfArray( array ) 
<BR>
function zeroOfColumn( column )
</LI>
<LI>ARGUMENTS

<UL>
<LI>type(ArrayT), intent(in) :: array 
<BR></LI>
<LI>type(ColumnT), intent(in) :: column 
<BR></LI>
</UL>
</LI>
<LI>RETURNS

<UL>
<LI>real(kind=DOUBLE) 
<BR></LI>
</UL>
</LI>
<LI>DESCRIPTION 
<BR></LI>
<LI>ERRORS 
<BR></LI>
<LI>EXAMPLES 
<BR></LI>
<LI>SEE ALSO 
<BR></LI>
<LI>BUGS AND LIMITATIONS 
<BR> 
</LI>
</UL> 

<P>
! Extended DAL

<P>
subroutine subTableSeek( table, from, count )
                type(SubTableT), intent(in) :: table
                integer, intent(in) :: from, count

<P>
call error( "", errorMessage )

<P>
end subroutine

<P>
end module Dal

<P>

<DIV CLASS="navigation"><IMG BORDER="0" SRC="../icons/bar.gif">
<BR><A HREF="node29.html"><IMG BORDER="0" SRC="../icons/prev.gif" ALT="Column"></A>
<A HREF="node18.html"><IMG BORDER="0" SRC="../icons/up.gif" ALT="F90 DAL API"></A>
<A HREF="node31.html"><IMG BORDER="0" SRC="../icons/next.gif" ALT="Errors"></A>
<A HREF="index.html"><IMG BORDER="0" SRC="../icons/home.gif" ALT="Home"></A>

<A HREF="node36.html"><IMG BORDER="0" SRC="../icons/index.gif" ALT="Index"></A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
XMM-Newton SOC/SSC -- 2017-01-12
</ADDRESS>
</BODY>
</HTML>
